<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to Explain the Prediction of a Machine Learning Model? | Lil&#39;Log</title>
<meta name="keywords" content="foundation" />
<meta name="description" content="The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.
Meanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life.">
<meta name="author" content="Lilian Weng">
<link rel="canonical" href="https://lilianweng.github.io/posts/2017-08-01-interpretation/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.67a6fb6e33089cb29e856bcc95d7aa39f70049a42b123105531265a0d9f1258b.css" integrity="sha256-Z6b7bjMInLKehWvMldeqOfcASaQrEjEFUxJloNnxJYs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js" integrity="sha256-W5rgME&#43;T22zEk/UYRvASQorzmcYUtPL723&#43;lndTV71s="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lilianweng.github.io/favicon_peach.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lilianweng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lilianweng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lilianweng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lilianweng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HFT45VFBX6"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-HFT45VFBX6', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="How to Explain the Prediction of a Machine Learning Model?" />
<meta property="og:description" content="The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.
Meanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lilianweng.github.io/posts/2017-08-01-interpretation/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-01T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2017-08-01T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to Explain the Prediction of a Machine Learning Model?"/>
<meta name="twitter:description" content="The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.
Meanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lilianweng.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to Explain the Prediction of a Machine Learning Model?",
      "item": "https://lilianweng.github.io/posts/2017-08-01-interpretation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to Explain the Prediction of a Machine Learning Model?",
  "name": "How to Explain the Prediction of a Machine Learning Model?",
  "description": "The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.\nMeanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life.",
  "keywords": [
    "foundation"
  ],
  "articleBody": " The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.\nMeanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life. However, it is hard to do so without enough trust in the models or an efficient procedure to explain unintended behavior, especially considering that the deep neural networks are born as black-boxes.\nThink of the following cases:\nThe financial industry is highly regulated and loan issuers are required by law to make fair decisions and explain their credit models to provide reasons whenever they decide to decline loan application. Medical diagnosis model is responsible for human life. How can we be confident enough to treat a patient as instructed by a black-box model? When using a criminal decision model to predict the risk of recidivism at the court, we have to make sure the model behaves in an equitable, honest and nondiscriminatory manner. If a self-driving car suddenly acts abnormally and we cannot explain why, are we gonna be comfortable enough to use the technique in real traffic in large scale? At Affirm, we are issuing tens of thousands of installment loans every day and our underwriting model has to provide declination reasons when the model rejects one’s loan application. That’s one of the many motivations for me to dig deeper and write this post. Model interpretability is a big field in machine learning. This review is never met to exhaust every study, but to serve as a starting point.\nInterpretable Models Lipton (2017) summarized the properties of an interpretable model in a theoretical review paper, “The mythos of model interpretability”: A human can repeat (“simulatability”) the computation process with a full understanding of the algorithm (“algorithmic transparency”) and every individual part of the model owns an intuitive explanation (“decomposability”).\nMany classic models have relatively simpler formation and naturally, come with a model-specific interpretation method. Meanwhile, new tools are being developed to help create better interpretable models (Been, Khanna, \u0026 Koyejo, 2016; Lakkaraju, Bach \u0026 Leskovec, 2016).\nRegression A general form of a linear regression model is:\n$$ y = w_0 + w_1 x_1 + w_2 x_2 + … + w_n x_n $$\nThe coefficients describe the change of the response triggered by one unit increase of the independent variables. The coefficients are not comparable directly unless the features have been standardized (check sklearn.preprocessing.StandardScalar and RobustScaler), since one unit of different features can refer to very different things. Without standardization, the product $w_i \\dot x_i$ can be used to quantify one feature’s contribution to the response.\nNaive Bayes Naive Bayes is named as “Naive” because it works on a very simplified assumption that features are independent of each other and each contributes to the output independently.\nGiven a feature vector $\\mathbf{x} = [x_1, x_2, \\dots, x_n]$ and a class label $c \\in \\{1, 2, \\dots, C\\}$, the probability of this data point belonging to this class is:\n$$ \\begin{aligned} p(c | x_1, x_2, \\dots, x_n) \u0026\\propto p(c, x_1, x_2, \\dots, x_n)\\\\ \u0026\\propto p(c) p(x_1 | c) p(x_2 | c) \\dots p(x_n | c)\\\\ \u0026\\propto p(c) \\prod_{i=1}^n p(x_i | c). \\end{aligned} $$ The Naive Bayes classifier is then defined as:\n$$ \\hat{y} = \\arg\\max_{c \\in 1, \\dots, C} p(c) \\prod_{i=1}^n p(x_i | c) $$\nBecause the model has learned the prior $p(x_i \\vert c)$ during the training, the contribution of an individual feature value can be easily measured by the posterior, $p(c \\vert x_i) = p(c)p(x_i \\vert c) / p(x_i)$.\nDecision Tree/Decision Lists Decision lists are a set of boolean functions, usually constructed by the syntax like if... then... else.... The if-condition contains a function involving one or multiple features and a boolean output. Decision lists are born with good interpretability and can be visualized in a tree structure. Many research on decision lists is driven by medical applications, where the interpretability is almost as crucial as the model itself.\nA few types of decision lists are briefly described below:\nFalling Rule Lists (FRL) (Wang and Rudin, 2015) has fully enforced monotonicity on feature values. One key point, for example in the binary classification context, is that the probability of prediction $Y=1$ associated with each rule decreases as one moves down the decision lists. Bayesian Rule List (BRL) (Letham et al., 2015) is a generative model that yields a posterior distribution over possible decision lists. Interpretable Decision Sets (IDS) (Lakkaraju, Bach \u0026 Leskovec, 2016) is a prediction framework to create a set of classification rules. The learning is optimized for both accuracy and interpretability simultaneously. IDS is closely related to the BETA method I’m gonna describe later for interpreting black-box models. Random Forests Weirdly enough, many people believe that the Random Forests model is a black box, which is not true. Considering that the output of random forests is the majority vote by a large number of independent decision trees and each tree is naturally interpretable.\nIt is not very hard to gauge the influence of individual features if we look into a single tree at a time. The global feature importance of random forests can be quantified by the total decrease in node impurity averaged over all trees of the ensemble (“mean decrease impurity”).\nFor one instance, because the decision paths in all the trees are well tracked, we can use the difference between the mean value of data points in a parent node between that of a child node to approximate the contribution of this split. Read more in this series of blog posts: Interpreting Random Forests.\nInterpreting Black-Box Models A lot of models are not designed to be interpretable. Approaches to explaining a black-box model aim to extract information from the trained model to justify its prediction outcome, without knowing how the model works in details. To keep the interpretation process independent from the model implementation is good for real-world applications: Even when the base model is being constantly upgraded and refined, the interpretation engine built on top would not worry about the changes.\nWithout the concern of keeping the model transparent and interpretable, we can endow the model with greater power of expressivity by adding more parameters and nonlinearity computation. That’s how deep neural networks become successful in tasks involving rich inputs.\nThere is no hard requirement on how the explanation should be presented, but the primary goal is mainly to answer: Can I trust this model? When we rely on the model to make a critical or life-and-death decision, we have to make sure the model is trustworthy ahead of time.\nThe interpretation framework should balance between two goals:\nFidelity: the prediction produced by an explanation should agree with the original model as much as possible. Interpretability: the explanation should be simple enough to be human-understandable. Side Notes: The next three methods are designed for local interpretation.\nPrediction Decomposition Robnik-Sikonja and Kononenko (2008) proposed to explain the model prediction for one instance by measuring the difference between the original prediction and the one made with omitting a set of features.\nLet’s say we need to generate an explanation for a classification model $f: \\mathbf{X} \\rightarrow \\mathbf{Y}$. Given a data point $x \\in X$ which consists of $a$ individual values of attribute $A_i$, $i = 1, \\dots, a$, and is labeled with class $y \\in Y$. The prediction difference is quantified by computing the difference between the model predicted probabilities with or without knowing $A_i$:\n$$ \\text{probDiff}_i (y | x) = p(y| x) - p(y | x \\backslash A_i) $$\n(The paper also discussed on using the odds ratio or the entropy-based information metric to quantify the prediction difference.)\nProblem: If the target model outputs a probability, then great, getting $ p(y \\vert x) $ is straightforward. Otherwise, the model prediction has to run through an appropriate post-modeling calibration to translate the prediction score into probabilities. This calibration layer is another piece of complication.\nAnother problem: If we generate $x \\backslash A_i$ by replacing $A_i$ with a missing value (like None, NaN, etc.), we have to rely on the model’s internal mechanism for missing value imputation. A model which replaces these missing cases with the median should have output very different from a model which imputes a special placeholder. One solution as presented in the paper is to replace $A_i$ with all possible values of this feature and then sum up the prediction weighted by how likely each value shows in the data:\n$$ \\begin{aligned} p(y \\vert x \\backslash A_i) \u0026= \\sum_{s=1}^{m_i} p(A_i=a_s \\vert x \\backslash A_i) p(y \\vert x \\leftarrow A_i=a_s) \\\\ \u0026\\approx \\sum_{s=1}^{m_i} p(A_i=a_s) p(y \\vert x \\leftarrow A_i=a_s) \\end{aligned} $$ Where $p(y \\vert x \\leftarrow A_i=a_s)$ is the probability of getting label $y$ if we replace the feature $A_i$ with value $a_s$ in the feature vector of $x$. There are $m_i$ unique values of $A_i$ in the training set.\nWith the help of the measures of prediction difference when omitting known features, we can decompose the impact of each individual feature on the prediction.\nFig. 1. Explanations for a SVM model predicting the survival of one male adult first-class passenger in the Titanic dataset. The information difference is very similar to the probability difference, but it measures the amount of information necessary to find out $y$ is true for the given instance without the knowledge of $A\\_i$: $\\text{infDiff}\\_i (y|x) = \\log\\_2 p(y|x) - \\log\\_2 p(y|x \\backslash A\\_i)$. Explanations for particular instance are depicted with dark bars. The light shaded half-height bars are average positive and negative explanations for given attributes' values. In this case, being a male adult makes it very less likely to survive; the class level does not impact as much. Local Gradient Explanation Vector This method (Baehrens, et al. 2010) is able to explain the local decision taken by arbitrary nonlinear classification algorithms, using the local gradients that characterize how a data point has to be moved to change its predicted label.\nLet’s say, we have a Bayes Classifier which is trained on the data set $X$ and outputs probabilities over the class labels $Y$, $p(Y=y \\vert X=x)$. And one class label $y$ is drawn from the class label pool, $\\{1, 2, \\dots, C\\}$. This Bayes classifier is constructed as:\n$$ f^{*}(x) = \\arg \\min_{c \\in \\{1, \\dots, C\\}} p(Y \\neq c \\vert X = x) $$\nThe local explanation vector is defined as the derivative of the probability prediction function at the test point $x = x_0$. A large entry in this vector highlights a feature with a big influence on the model decision; A positive sign indicates that increasing the feature would lower the probability of $x_0$ assigned to $f^{*}(x_0)$.\nHowever, this approach requires the model output to be a probability (similar to the “Prediction Decomposition” method above). What if the original model (labelled as $f$) is not calibrated to yield probabilities? As suggested by the paper, we can approximate $f$ by another classifier in a form that resembles the Bayes classifier $f^{*}$:\n(1) Apply Parzen window to the training data to estimate the weighted class densities:\n$$ \\hat{p}_{\\sigma}(x, y=c) = \\frac{1}{n} \\sum_{i \\in I_c} k_{\\sigma} (x - x_i) $$\nWhere $I_c$ is the index set containing the indices of data points assigned to class $c$ by the model $f$, $I_c = \\{i \\vert f(x_i) = c\\}$. $k_{\\sigma}$ is a kernel function. Gaussian kernel is a popular one among many candidates.\n(2) Then, apply the Bayes’ rule to approximate the probability $p(Y=c \\vert X=x)$ for all classes:\n$$ \\begin{aligned} \\hat{p}_{\\sigma}(y=c | x) \u0026= \\frac{\\hat{p}_{\\sigma}(x, y=c)}{\\hat{p}_{\\sigma}(x, y=c) + \\hat{p}_{\\sigma}(x, y \\neq c)} \\\\ \u0026\\approx \\frac{\\sum_{i \\in I_c} k_{\\sigma} (x - x_i)}{\\sum_i k_{\\sigma} (x - x_i)} \\end{aligned} $$ (3) The final estimated Bayes classifier takes the form:\n$$ \\hat{f}_{\\sigma} = \\arg\\min_{c \\in \\{1, \\dots, C\\}} \\hat{p}_{\\sigma}(y \\neq c \\vert x) $$\nNoted that we can generate the labeled data with the original model $f$, as much as we want, not restricted by the size of the training data. The hyperparameter $\\sigma$ is selected to optimize the chances of $\\hat{f}_{\\sigma}(x) = f(x)$ to achieve high fidelity.\nFig. 2. An example of how local gradient explanation vector is applied on simple object classification with Gaussian Processes Classifier (GPC). The GPC model outputs the probability by nature. (a) shows the training points and their labels in red (positive 1) and blue (negative -1). (b) illustrates a probability function for the positive class. (c-d) shows the local gradients and the directions of the local explanation vectors. Side notes: As you can see both the methods above require the model prediction to be a probability. Calibration of the model output adds another layer of complication.\nLIME (Local Interpretable Model-Agnostic Explanations) LIME, short for local interpretable model-agnostic explanation, can approximate a black-box model locally in the neighborhood of the prediction we are interested (Ribeiro, Singh, \u0026 Guestrin, 2016).\nSame as above, let us label the black-box model as $f$. LIME presents the following steps:\n(1) Convert the dataset into interpretable data representation: $x \\Rightarrow x_b$.\nText classifier: a binary vector indicating the presence or absence of a word Image classifier: a binary vector indicating the presence or absence of a contiguous patch of similar pixels (super-pixel). Fig. 3. An example of converting an image into interpretable data representation. (Image source: www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime) (2) Given a prediction $f(x)$ with the corresponding interpretable data representation $x_b$, let us sample instances around $x_b$ by drawing nonzero elements of $x_b$ uniformly at random where the number of such draws is also uniformly sampled. This process generates a perturbed sample $z_b$ which contains a fraction of nonzero elements of $x_b$.\nThen we recover $z_b$ back into the original input $z$ and get a prediction score $f(z)$ by the target model.\nUse many such sampled data points $z_b \\in \\mathcal{Z}_b$ and their model predictions, we can learn an explanation model (such as in a form as simple as a regression) with local fidelity. The sampled data points are weighted differently based on how close they are to $x_b$. The paper used a lasso regression with preprocessing to select top $k$ most significant features beforehand, named “K-LASSO”.\nFig. 4. The pink and blue areas are two classes predicted by the black-box model $f$. the big red cross is the point to be explained and other smaller crosses (predicted as pink by $f$) and dots (predicted as blue by $f$) are sampled data points. Even though the model can be very complicated, we are still able to learn a local explanation model as simple as the grey dash line. (Image source: homes.cs.washington.edu/~marcotcr/blog/lime) Examining whether the explanation makes sense can directly decide whether the model is trustworthy because sometimes the model can pick up spurious correlation or generalization. One interesting example in the paper is to apply LIME on an SVM text classifier for differentiating “Christianity” from “Atheism”. The model achieved a pretty good accuracy (94% on held-out testing set!), but the LIME explanation demonstrated that decisions were made by very arbitrary reasons, such as counting the words “re”, “posting” and “host” which have no connection with neither “Christianity” nor “Atheism” directly. After such a diagnosis, we learned that even the model gives us a nice accuracy, it cannot be trusted. It also shed lights on ways to improve the model, such as better preprocessing on the text.\nFig. 5. Illustration of how to use LIME on an image classifier. (Image source: www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime) For more detailed non-paper explanation, please read this blog post by the author. A very nice read.\nSide Notes: Interpreting a model locally is supposed to be easier than interpreting the model globally, but harder to maintain (thinking about the curse of dimensionality). Methods described below aim to explain the behavior of a model as a whole. However, the global approach is unable to capture the fine-grained interpretation, such as a feature might be important in this region but not at all in another.\nFeature Selection Essentially all the classic feature selection methods (Yang and Pedersen, 1997; Guyon and Elisseeff, 2003) can be considered as ways to explain a model globally. Feature selection methods decompose the contribution of multiple features so that we can explain the overall model output by individual feature impact.\nThere are a ton of resources on feature selection so I would skip the topic in this post.\nBETA (Black Box Explanation through Transparent Approximations) BETA, short for black box explanation through transparent approximations, is closely connected to Interpretable Decision Sets (Lakkaraju, Bach \u0026 Leskovec, 2016). BETA learns a compact two-level decision set in which each rule explains part of the model behavior unambiguously.\nThe authors proposed an novel objective function so that the learning process is optimized for high fidelity (high agreement between explanation and the model), low unambiguity (little overlaps between decision rules in the explanation), and high interpretability (the explanation decision set is lightweight and small). These aspects are combined into one objection function to optimize for.\nFig. 6. Measures for desiderata of a good model explanation: fidelity, unambiguity, and interpretability. Given the target model is $\\mathcal{B}$, its explanation is a two level decision set $\\Re$ containing a set of rules ${(q\\_1, s\\_1, c\\_1), \\dots, (q\\_M, s\\_M, c\\_M)}$, where $q\\_i$ and $s\\_i$ are conjunctions of predicates of the form (feature, operator, value) and $c\\_i$ is a class label. Check the paper for more details. (Image source: arxiv.org/abs/1707.01154) Explainable Artificial Intelligence I borrow the name of this section from the DARPA project “Explainable Artificial Intelligence”. This Explainable AI (XAI) program aims to develop more interpretable models and to enable human to understand, appropriately trust, and effectively manage the emerging generation of artificially intelligent techniques.\nWith the progress of the deep learning applications, people start worrying about that we may never know even if the model goes bad. The complicated structure, the large number of learnable parameters, the nonlinear mathematical operations and some intriguing properties (Szegedy et al., 2014) lead to the un-interpretability of deep neural networks, creating a true black-box. Although the power of deep learning is originated from this complexity — more flexible to capture rich and intricate patterns in the real-world data.\nStudies on adversarial examples (OpenAI Blog: Robust Adversarial Examples, Attacking Machine Learning with Adversarial Examples, Goodfellow, Shlens \u0026 Szegedy, 2015; Nguyen, Yosinski, \u0026 Clune, 2015) raise the alarm on the robustness and safety of AI applications. Sometimes the models could show unintended, unexpected and unpredictable behavior and we have no fast/good strategy to tell why.\nFig. 7. Illustrations of adversarial examples. (a-d) are adversarial images that are generated by adding human-imperceptible noises onto original images (Szegedy et al., 2013). A well-trained neural network model can successfully classify original ones but fail adversarial ones. (e-h) are patterns that are generated (Nguyen, Yosinski \u0026 Clune, 2015). A well-trained neural network model labels them into (e) school bus, (f) guitar, (g) peacock and (h) Pekinese respectively. (Image source: Wang, Raj \u0026 Xing, 2017) Nvidia recently developed a method to visualize the most important pixel points in their self-driving cars’ decisioning process. The visualization provides insights on how AI thinks and what the system relies on while operating the car. If what the AI believes to be important agrees with how human make similar decisions, we can naturally gain more confidence in the black-box model.\nMany exciting news and findings are happening in this evolving field every day. Hope my post can give you some pointers and encourage you to investigate more into this topic :)\nCited as:\n@article{weng2017gan, title = \"How to Explain the Prediction of a Machine Learning Model?\", author = \"Weng, Lilian\", journal = \"lilianweng.github.io\", year = \"2017\", url = \"https://lilianweng.github.io/posts/2017-08-01-interpretation/\" } References [1] Zachary C. Lipton. “The mythos of model interpretability.” arXiv preprint arXiv:1606.03490 (2016).\n[2] Been Kim, Rajiv Khanna, and Oluwasanmi O. Koyejo. “Examples are not enough, learn to criticize! criticism for interpretability.” Advances in Neural Information Processing Systems. 2016.\n[3] Himabindu Lakkaraju, Stephen H. Bach, and Jure Leskovec. “Interpretable decision sets: A joint framework for description and prediction.” Proc. 22nd ACM SIGKDD Intl. Conf. on Knowledge Discovery and Data Mining. ACM, 2016.\n[4] Robnik-Šikonja, Marko, and Igor Kononenko. “Explaining classifications for individual instances.” IEEE Transactions on Knowledge and Data Engineering 20.5 (2008): 589-600.\n[5] Baehrens, David, et al. “How to explain individual classification decisions.” Journal of Machine Learning Research 11.Jun (2010): 1803-1831.\n[6] Marco Tulio Ribeiro, Sameer Singh, and Carlos Guestrin. “Why should I trust you?: Explaining the predictions of any classifier.” Proc. 22nd ACM SIGKDD Intl. Conf. on Knowledge Discovery and Data Mining. ACM, 2016.\n[7] Yiming Yang, and Jan O. Pedersen. “A comparative study on feature selection in text categorization.” Intl. Conf. on Machine Learning. Vol. 97. 1997.\n[8] Isabelle Guyon, and André Elisseeff. “An introduction to variable and feature selection.” Journal of Machine Learning Research 3.Mar (2003): 1157-1182.\n[9] Ian J. Goodfellow, Jonathon Shlens, and Christian Szegedy. “Explaining and harnessing adversarial examples.” ICLR 2015.\n[10] Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow, Rob Fergus. “Intriguing properties of neural networks.” Intl. Conf. on Learning Representations (2014)\n[11] Nguyen, Anh, Jason Yosinski, and Jeff Clune. “Deep neural networks are easily fooled: High confidence predictions for unrecognizable images.” Proc. IEEE Conference on Computer Vision and Pattern Recognition. 2015.\n[12] Benjamin Letham, Cynthia Rudin, Tyler H. McCormick, and David Madigan. “Interpretable classifiers using rules and Bayesian analysis: Building a better stroke prediction model.” The Annals of Applied Statistics 9, No. 3 (2015): 1350-1371.\n[13] Haohan Wang, Bhiksha Raj, and Eric P. Xing. “On the Origin of Deep Learning.” arXiv preprint arXiv:1702.07800 (2017).\n[14] OpenAI Blog: Robust Adversarial Examples\n[15] Attacking Machine Learning with Adversarial Examples\n[16] Reading an AI Car’s Mind: How NVIDIA’s Neural Net Makes Decisions\n",
  "wordCount" : "3636",
  "inLanguage": "en",
  "datePublished": "2017-08-01T00:00:00Z",
  "dateModified": "2017-08-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lilian Weng"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lilianweng.github.io/posts/2017-08-01-interpretation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lil'Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lilianweng.github.io/favicon_peach.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lilianweng.github.io/" accesskey="h" title="Lil&#39;Log (Alt + H)">Lil&#39;Log</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lilianweng.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/faq" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="emojisearch.app">
                    <span>emojisearch.app</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      How to Explain the Prediction of a Machine Learning Model?
    </h1>
    <div class="post-meta">Date: August 1, 2017  |  Estimated Reading Time: 18 min  |  Author: Lilian Weng

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#interpretable-models" aria-label="Interpretable Models">Interpretable Models</a><ul>
                        
                <li>
                    <a href="#regression" aria-label="Regression">Regression</a></li>
                <li>
                    <a href="#naive-bayes" aria-label="Naive Bayes">Naive Bayes</a></li>
                <li>
                    <a href="#decision-treedecision-lists" aria-label="Decision Tree/Decision Lists">Decision Tree/Decision Lists</a></li>
                <li>
                    <a href="#random-forests" aria-label="Random Forests">Random Forests</a></li></ul>
                </li>
                <li>
                    <a href="#interpreting-black-box-models" aria-label="Interpreting Black-Box Models">Interpreting Black-Box Models</a><ul>
                        
                <li>
                    <a href="#prediction-decomposition" aria-label="Prediction Decomposition">Prediction Decomposition</a></li>
                <li>
                    <a href="#local-gradient-explanation-vector" aria-label="Local Gradient Explanation Vector">Local Gradient Explanation Vector</a></li>
                <li>
                    <a href="#lime-local-interpretable-model-agnostic-explanations" aria-label="LIME (Local Interpretable Model-Agnostic Explanations)">LIME (Local Interpretable Model-Agnostic Explanations)</a></li>
                <li>
                    <a href="#feature-selection" aria-label="Feature Selection">Feature Selection</a></li>
                <li>
                    <a href="#beta-black-box-explanation-through-transparent-approximations" aria-label="BETA (Black Box Explanation through Transparent Approximations)">BETA (Black Box Explanation through Transparent Approximations)</a></li></ul>
                </li>
                <li>
                    <a href="#explainable-artificial-intelligence" aria-label="Explainable Artificial Intelligence">Explainable Artificial Intelligence</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><!-- This post reviews some research in model interpretability, covering two aspects: (i) interpretable models with model-specific interpretation methods and (ii) approaches of explaining black-box models. I included an open discussion on explainable artificial intelligence at the end. -->
<p>The machine learning models have started penetrating into critical areas like health care, justice systems, and financial industry. Thus to figure out how the models make the decisions and make sure the decisioning process is aligned with the ethnic requirements or legal regulations becomes a necessity.</p>
<p>Meanwhile, the rapid growth of deep learning models pushes the requirement of interpreting complicated models further. People are eager to apply the power of AI fully on key aspects of everyday life. However, it is hard to do so without enough trust in the models or an efficient procedure to explain unintended behavior, especially considering that the deep neural networks are born as <em>black-boxes</em>.</p>
<p>Think of the following cases:</p>
<ol>
<li>The financial industry is highly regulated and loan issuers are required by law to make fair decisions and explain their credit models to provide reasons whenever they decide to decline loan application.</li>
<li>Medical diagnosis model is responsible for human life. How can we be confident enough to treat a patient as instructed by a black-box model?</li>
<li>When using a criminal decision model to predict the risk of recidivism at the court, we have to make sure the model behaves in an equitable, honest and nondiscriminatory manner.</li>
<li>If a self-driving car suddenly acts abnormally and we cannot explain why, are we gonna be comfortable enough to use the technique in real traffic in large scale?</li>
</ol>
<p>At <a href="https://www.affirm.com/">Affirm</a>, we are issuing tens of thousands of installment loans every day and our underwriting model has to provide declination reasons when the model rejects one&rsquo;s loan application. That&rsquo;s one of the many motivations for me to dig deeper and write this post. Model interpretability is a big field in machine learning. This review is never met to exhaust every study, but to serve as a starting point.</p>
<hr>
<h1 id="interpretable-models">Interpretable Models<a hidden class="anchor" aria-hidden="true" href="#interpretable-models">#</a></h1>
<p>Lipton (2017) summarized the properties of an interpretable model in a theoretical review paper, <a href="https://arxiv.org/pdf/1606.03490.pdf">&ldquo;The mythos of model interpretability&rdquo;</a>: A human can repeat (<em>&ldquo;simulatability&rdquo;</em>) the computation process with a full understanding of the algorithm (<em>&ldquo;algorithmic transparency&rdquo;</em>) and every individual part of the model owns an intuitive explanation (<em>&ldquo;decomposability&rdquo;</em>).</p>
<p>Many classic models have relatively simpler formation and naturally, come with a model-specific interpretation method. Meanwhile, new tools are being developed to help create better interpretable models (<a href="http://papers.nips.cc/paper/6300-examples-are-not-enough-learn-to-criticize-criticism-for-interpretability.pdf">Been, Khanna, &amp; Koyejo, 2016</a>; <a href="http://www.kdd.org/kdd2016/papers/files/rpp1067-lakkarajuA.pdf">Lakkaraju, Bach &amp; Leskovec, 2016</a>).</p>
<h2 id="regression">Regression<a hidden class="anchor" aria-hidden="true" href="#regression">#</a></h2>
<p>A general form of a linear regression model is:</p>
<p>$$
y = w_0 + w_1 x_1 + w_2 x_2 + … + w_n x_n
$$</p>
<p>The coefficients describe the change of the response triggered by one unit increase of the independent variables. The coefficients are not comparable directly unless the features have been standardized (check sklearn.preprocessing.<a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html#sklearn.preprocessing.StandardScaler">StandardScalar</a> and <a href="http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html#sklearn.preprocessing.RobustScaler">RobustScaler</a>), since one unit of different features can refer to very different things. Without standardization, the product $w_i \dot x_i$ can be used to quantify one feature&rsquo;s contribution to the response.</p>
<h2 id="naive-bayes">Naive Bayes<a hidden class="anchor" aria-hidden="true" href="#naive-bayes">#</a></h2>
<p>Naive Bayes is named as &ldquo;Naive&rdquo; because it works on a very simplified assumption that features are independent of each other and each contributes to the output independently.</p>
<p>Given a feature vector $\mathbf{x} = [x_1, x_2, \dots, x_n]$ and a class label $c \in \{1, 2, \dots, C\}$, the probability of this data point belonging to this class is:</p>
<div>
$$
\begin{aligned}
p(c | x_1, x_2, \dots, x_n) 
&\propto p(c, x_1, x_2, \dots, x_n)\\
&\propto p(c) p(x_1 | c) p(x_2 | c) \dots p(x_n | c)\\
&\propto p(c) \prod_{i=1}^n p(x_i | c).
\end{aligned}
$$
</div>
<p>The Naive Bayes classifier is then defined as:</p>
<p>$$
\hat{y} = \arg\max_{c \in 1, \dots, C} p(c) \prod_{i=1}^n p(x_i | c)
$$</p>
<p>Because the model has learned the prior $p(x_i \vert c)$ during the training, the contribution of an individual feature value can be easily measured by the posterior, $p(c \vert x_i) = p(c)p(x_i \vert c) / p(x_i)$.</p>
<h2 id="decision-treedecision-lists">Decision Tree/Decision Lists<a hidden class="anchor" aria-hidden="true" href="#decision-treedecision-lists">#</a></h2>
<p>Decision lists are a set of boolean functions, usually constructed by the syntax like <code>if... then... else...</code>. The if-condition contains a function involving one or multiple features and a boolean output. Decision lists are born with good interpretability and can be visualized in a tree structure. Many research on decision lists is driven by medical applications, where the interpretability is almost as crucial as the model itself.</p>
<p>A few types of decision lists are briefly described below:</p>
<ul>
<li><a href="http://proceedings.mlr.press/v38/wang15a.pdf">Falling Rule Lists (FRL)</a> (Wang and Rudin, 2015) has fully enforced monotonicity on feature values. One key point, for example in the binary classification context, is that the probability of prediction $Y=1$ associated with each rule decreases as one moves down the decision lists.</li>
<li><a href="https://arxiv.org/abs/1511.01644">Bayesian Rule List (BRL)</a> (Letham et al., 2015) is a generative model that yields a posterior distribution over possible decision lists.</li>
<li><a href="https://cs.stanford.edu/people/jure/pubs/interpretable-kdd16.pdf">Interpretable Decision Sets (IDS)</a> (Lakkaraju, Bach &amp; Leskovec, 2016) is a prediction framework to create a set of classification rules. The learning is optimized for both accuracy and interpretability simultaneously. IDS is closely related to the BETA method I&rsquo;m gonna describe <a href="https://lilianweng.github.io/posts/2017-08-01-interpretation/#beta-black-box-explanation-through-transparent-approximations">later</a> for interpreting black-box models.</li>
</ul>
<h2 id="random-forests">Random Forests<a hidden class="anchor" aria-hidden="true" href="#random-forests">#</a></h2>
<p>Weirdly enough, many people believe that the <a href="http://www.math.univ-toulouse.fr/~agarivie/Telecom/apprentissage/articles/randomforest2001.pdf">Random Forests</a> model is a black box, which is not true. Considering that the output of random forests is the majority vote by a large number of independent decision trees and each tree is naturally interpretable.</p>
<p>It is not very hard to gauge the influence of individual features if we look into a single tree at a time. The global feature importance of random forests can be quantified by the total decrease in node impurity averaged over all trees of the ensemble (&ldquo;mean decrease impurity&rdquo;).</p>
<p>For one instance, because the decision paths in all the trees are well tracked, we can use the difference between the mean value of data points in a parent node between that of a child node to approximate the contribution of this split. Read more in this series of blog posts: <a href="http://blog.datadive.net/interpreting-random-forests/">Interpreting Random Forests</a>.</p>
<h1 id="interpreting-black-box-models">Interpreting Black-Box Models<a hidden class="anchor" aria-hidden="true" href="#interpreting-black-box-models">#</a></h1>
<p>A lot of models are not designed to be interpretable. Approaches to explaining a black-box model aim to extract information from the trained model to justify its prediction outcome, without knowing how the model works in details. To keep the interpretation process independent from the model implementation is good for real-world applications: Even when the base model is being constantly upgraded and refined, the interpretation engine built on top would not worry about the changes.</p>
<p>Without the concern of keeping the model transparent and interpretable, we can endow the model with greater power of expressivity by adding more parameters and nonlinearity computation. That&rsquo;s how deep neural networks become successful in tasks involving rich inputs.</p>
<p>There is no hard requirement on how the explanation should be presented, but the primary goal is mainly to answer: <strong>Can I trust this model?</strong> When we rely on the model to make a critical or life-and-death decision, we have to make sure the model is trustworthy ahead of time.</p>
<p>The interpretation framework should balance between two goals:</p>
<ul>
<li><strong>Fidelity</strong>: the prediction produced by an explanation should agree with the original model as much as possible.</li>
<li><strong>Interpretability</strong>: the explanation should be simple enough to be human-understandable.</li>
</ul>
<blockquote>
<p>Side Notes: The next three methods are designed for local interpretation.</p>
</blockquote>
<h2 id="prediction-decomposition">Prediction Decomposition<a hidden class="anchor" aria-hidden="true" href="#prediction-decomposition">#</a></h2>
<p><a href="http://lkm.fri.uni-lj.si/rmarko/papers/RobnikSikonjaKononenko08-TKDE.pdf">Robnik-Sikonja and Kononenko (2008)</a> proposed to explain the model prediction for one instance by measuring the difference between the original prediction and the one made with omitting a set of features.</p>
<p>Let&rsquo;s say we need to generate an explanation for a classification model $f: \mathbf{X} \rightarrow \mathbf{Y}$. Given a data point $x \in X$ which consists of $a$ individual values of attribute $A_i$, $i = 1, \dots, a$, and is labeled with class $y \in Y$. The <em>prediction difference</em> is quantified by computing the difference between the model predicted probabilities with or without knowing $A_i$:</p>
<p>$$
\text{probDiff}_i (y | x)  = p(y| x) - p(y | x \backslash A_i)
$$</p>
<p>(The paper also discussed on using the odds ratio or the entropy-based information metric to quantify the prediction difference.)</p>
<p><strong>Problem</strong>: If the target model outputs a probability, then great, getting $ p(y \vert x) $ is straightforward. Otherwise, the model prediction has to run through an appropriate post-modeling calibration to translate the prediction score into probabilities. This calibration layer is another piece of complication.</p>
<p><strong>Another problem</strong>: If we generate $x \backslash A_i$ by replacing $A_i$ with a missing value (like <code>None</code>, <code>NaN</code>, etc.), we have to rely on the model&rsquo;s internal mechanism for missing value imputation. A model which replaces these missing cases with the median should have output very different from a model which imputes a special placeholder. One solution as presented in the paper is to replace $A_i$ with all possible values of this feature and then sum up the prediction weighted by how likely each value shows in the data:</p>
<div>
$$
\begin{aligned}
p(y \vert x \backslash A_i)
&= \sum_{s=1}^{m_i} p(A_i=a_s \vert x \backslash A_i) p(y \vert x \leftarrow A_i=a_s) \\
&\approx \sum_{s=1}^{m_i} p(A_i=a_s) p(y \vert x \leftarrow A_i=a_s)
\end{aligned}
$$
</div>
<p>Where $p(y \vert x \leftarrow A_i=a_s)$ is the probability of getting label $y$ if we replace the feature $A_i$ with value $a_s$ in the feature vector of $x$. There are $m_i$ unique values of $A_i$ in the training set.</p>
<p>With the help of the measures of prediction difference when omitting known features, we can <em>decompose</em> the impact of each individual feature on the prediction.</p>
<img src="interpretability_prediction_decomposition.png" style="width: 400px;" class="center" />
<figcaption>Fig. 1. Explanations for a SVM model predicting the survival of one male adult first-class passenger in the <a href="https://www.kaggle.com/c/titanic/data" target="_blank">Titanic dataset</a>. The information difference is very similar to the probability difference, but it measures the amount of information necessary to find out $y$ is true for the given instance without the knowledge of $A\_i$: $\text{infDiff}\_i (y|x) = \log\_2 p(y|x) - \log\_2 p(y|x \backslash A\_i)$. Explanations for particular instance are depicted with dark bars. The light shaded half-height bars are average positive and negative explanations for given attributes' values. In this case, being a male adult makes it very less likely to survive; the class level does not impact as much.</figcaption>
<h2 id="local-gradient-explanation-vector">Local Gradient Explanation Vector<a hidden class="anchor" aria-hidden="true" href="#local-gradient-explanation-vector">#</a></h2>
<p>This method (<a href="http://www.jmlr.org/papers/volume11/baehrens10a/baehrens10a.pdf">Baehrens, et al. 2010</a>) is able to explain the local decision taken by arbitrary nonlinear classification algorithms, using the local gradients that characterize how a data point has to be moved to change its predicted label.</p>
<p>Let&rsquo;s say, we have a <a href="https://en.wikipedia.org/wiki/Bayes_classifier">Bayes Classifier</a> which is trained on the data set $X$ and outputs probabilities over the class labels $Y$, $p(Y=y \vert X=x)$. And one class label $y$ is drawn from the class label pool, $\{1, 2, \dots, C\}$. This Bayes classifier is constructed as:</p>
<p>$$
f^{*}(x)  = \arg \min_{c \in \{1, \dots, C\}} p(Y \neq c \vert X = x)
$$</p>
<p>The <em>local explanation vector</em> is defined as the derivative of the probability prediction function at the test point $x = x_0$. A large entry in this vector highlights a feature with a big influence on the model decision; A positive sign indicates that increasing the feature would lower the probability of $x_0$ assigned to $f^{*}(x_0)$.</p>
<p>However, this approach requires the model output to be a probability (similar to the <a href="https://lilianweng.github.io/posts/2017-08-01-interpretation/#prediction-decomposition">&ldquo;Prediction Decomposition&rdquo;</a> method above). What if the original model (labelled as $f$) is not calibrated to yield probabilities? As suggested by the paper, we can approximate $f$ by another classifier in a form that resembles the Bayes classifier $f^{*}$:</p>
<p>(1) Apply <a href="https://en.wikipedia.org/?title=Parzen_window&amp;redirect=no">Parzen window</a> to the training data to estimate the weighted class densities:</p>
<p>$$
\hat{p}_{\sigma}(x, y=c) = \frac{1}{n} \sum_{i \in I_c} k_{\sigma} (x - x_i)
$$</p>
<p>Where $I_c$ is the index set containing the indices of data points assigned to class $c$ by the model $f$, $I_c = \{i \vert f(x_i) = c\}$. $k_{\sigma}$ is a kernel function. Gaussian kernel is a popular one among <a href="https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use">many candidates</a>.</p>
<p>(2) Then, apply the Bayes&rsquo; rule to approximate the probability $p(Y=c \vert X=x)$ for all classes:</p>
<div>
$$
\begin{aligned}
\hat{p}_{\sigma}(y=c | x)
&= \frac{\hat{p}_{\sigma}(x, y=c)}{\hat{p}_{\sigma}(x, y=c) + \hat{p}_{\sigma}(x, y \neq c)} \\
&\approx \frac{\sum_{i \in I_c} k_{\sigma} (x - x_i)}{\sum_i k_{\sigma} (x - x_i)}
\end{aligned}
$$
</div>
<p>(3) The final estimated Bayes classifier takes the form:</p>
<p>$$
\hat{f}_{\sigma} = \arg\min_{c \in \{1, \dots, C\}} \hat{p}_{\sigma}(y \neq c \vert x)
$$</p>
<p>Noted that we can generate the labeled data with the original model $f$, as much as we want, not restricted by the size of the training data. The hyperparameter $\sigma$ is selected to optimize the chances of $\hat{f}_{\sigma}(x) = f(x)$ to achieve high fidelity.</p>
<img src="interpretability_local_gradient.png" style="width: 560px;" class="center" />
<figcaption>Fig. 2. An example of how local gradient explanation vector is applied on simple object classification with Gaussian Processes Classifier (GPC). The GPC model outputs the probability by nature. (a) shows the training points and their labels in red (positive 1) and blue (negative -1). (b) illustrates a probability function for the positive class. (c-d) shows the local gradients and the directions of the local explanation vectors.</figcaption>
<blockquote>
<p>Side notes: As you can see both the methods above require the model prediction to be a probability. Calibration of the model output adds another layer of complication.</p>
</blockquote>
<h2 id="lime-local-interpretable-model-agnostic-explanations">LIME (Local Interpretable Model-Agnostic Explanations)<a hidden class="anchor" aria-hidden="true" href="#lime-local-interpretable-model-agnostic-explanations">#</a></h2>
<p><a href="https://github.com/marcotcr/lime">LIME</a>, short for <em>local interpretable model-agnostic explanation</em>, can approximate a black-box model locally in the neighborhood of the prediction we are interested (<a href="https://arxiv.org/pdf/1602.04938.pdf">Ribeiro, Singh, &amp; Guestrin, 2016</a>).</p>
<p>Same as above, let us label the black-box model as $f$. LIME presents the following steps:</p>
<p>(1) Convert the dataset into interpretable data representation: $x \Rightarrow x_b$.</p>
<ul>
<li>Text classifier: a binary vector indicating the presence or absence of a word</li>
<li>Image classifier: a binary vector indicating the presence or absence of a contiguous patch of similar pixels (super-pixel).</li>
</ul>
<img src="LIME_interpretable_representation.png" style="width: 480px;" class="center" />
<figcaption>Fig. 3. An example of converting an image into interpretable data representation. (Image source: <a href="https://www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime" target="_blank">www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime</a>)</figcaption>
<p>(2) Given a prediction $f(x)$ with the corresponding interpretable data representation $x_b$, let us sample instances around $x_b$ by drawing nonzero elements of $x_b$ uniformly at random where the number of such draws is also uniformly sampled. This process generates a perturbed sample $z_b$ which contains a fraction of nonzero elements of $x_b$.</p>
<p>Then we recover $z_b$ back into the original input $z$ and get a prediction score $f(z)$ by the target model.</p>
<p>Use many such sampled data points $z_b \in \mathcal{Z}_b$ and their model predictions, we can learn an explanation model (such as in a form as simple as a regression) with local fidelity. The sampled data points are weighted differently based on how close they are to $x_b$. The paper used a lasso regression with preprocessing to select top $k$ most significant features beforehand, named &ldquo;K-LASSO&rdquo;.</p>
<img src="LIME_illustration.png" style="width: 380px;" class="center" />
<figcaption>Fig. 4. The pink and blue areas are two classes predicted by the black-box model $f$. the big red cross is the point to be explained and other smaller crosses (predicted as pink by $f$) and dots (predicted as blue by $f$) are sampled data points. Even though the model can be very complicated, we are still able to learn a local explanation model as simple as the grey dash line. (Image source: <a href="https://homes.cs.washington.edu/~marcotcr/blog/lime/" target="_blank">homes.cs.washington.edu/~marcotcr/blog/lime</a>)</figcaption>
<p>Examining whether the explanation makes sense can directly decide whether the model is trustworthy because sometimes the model can pick up spurious correlation or generalization. One interesting example in the paper is to apply LIME on an SVM text classifier for differentiating &ldquo;Christianity&rdquo; from &ldquo;Atheism&rdquo;. The model achieved a pretty good accuracy (94% on held-out testing set!), but the LIME explanation demonstrated that decisions were made by very arbitrary reasons, such as counting the words &ldquo;re&rdquo;, &ldquo;posting&rdquo; and &ldquo;host&rdquo; which have no connection with neither &ldquo;Christianity&rdquo; nor &ldquo;Atheism&rdquo; directly. After such a diagnosis, we learned that even the model gives us a nice accuracy, it cannot be trusted. It also shed lights on ways to improve the model, such as better preprocessing on the text.</p>
<img src="LIME.png" class="center" />
<figcaption>Fig. 5. Illustration of how to use LIME on an image classifier. (Image source: <a href="https://www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime" target="_blank">www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime</a>)</figcaption>
<p>For more detailed non-paper explanation, please read <a href="https://www.oreilly.com/learning/introduction-to-local-interpretable-model-agnostic-explanations-lime">this blog post</a> by the author. A very nice read.</p>
<blockquote>
<p>Side Notes: Interpreting a model locally is supposed to be easier than interpreting the model globally, but harder to maintain (thinking about the <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a>). Methods described below aim to explain the behavior of a model as a whole. However, the global approach is unable to capture the fine-grained interpretation, such as a feature might be important in this region but not at all in another.</p>
</blockquote>
<h2 id="feature-selection">Feature Selection<a hidden class="anchor" aria-hidden="true" href="#feature-selection">#</a></h2>
<p>Essentially all the classic feature selection methods (<a href="http://www.surdeanu.info/mihai/teaching/ista555-spring15/readings/yang97comparative.pdf">Yang and Pedersen, 1997</a>; <a href="http://www.jmlr.org/papers/volume3/guyon03a/guyon03a.pdf">Guyon and Elisseeff, 2003</a>) can be considered as ways to explain a model globally. Feature selection methods decompose the contribution of multiple features so that we can explain the overall model output by individual feature impact.</p>
<p>There are a ton of resources on feature selection so I would skip the topic in this post.</p>
<h2 id="beta-black-box-explanation-through-transparent-approximations">BETA (Black Box Explanation through Transparent Approximations)<a hidden class="anchor" aria-hidden="true" href="#beta-black-box-explanation-through-transparent-approximations">#</a></h2>
<p><a href="https://arxiv.org/abs/1707.01154">BETA</a>, short for <em>black box explanation through transparent approximations</em>, is closely connected to <a href="https://cs.stanford.edu/people/jure/pubs/interpretable-kdd16.pdf">Interpretable Decision Sets</a> (Lakkaraju, Bach &amp; Leskovec, 2016). BETA learns a compact two-level decision set in which each rule explains part of the model behavior unambiguously.</p>
<p>The authors proposed an novel objective function so that the learning process is optimized for <strong>high fidelity</strong> (high agreement between explanation and the model), <strong>low unambiguity</strong> (little overlaps between decision rules in the explanation), and <strong>high interpretability</strong> (the explanation decision set is lightweight and small). These aspects are combined into one objection function to optimize for.</p>
<img src="BETA.png" style="width: 580px; margin-bottom: 10px;" class="center" />
<figcaption>Fig. 6. Measures for desiderata of a good model explanation: fidelity, unambiguity, and interpretability. Given the target model is $\mathcal{B}$, its explanation is a two level decision set $\Re$ containing a set of rules ${(q\_1, s\_1, c\_1), \dots, (q\_M, s\_M, c\_M)}$, where $q\_i$ and $s\_i$ are conjunctions of predicates of the form (feature, operator, value) and $c\_i$ is a class label. Check <a href="https://arxiv.org/abs/1707.01154" target="_blank">the paper</a> for more details. (Image source: <a href="https://arxiv.org/abs/1707.01154" target="_blank">arxiv.org/abs/1707.01154</a>)</figcaption>
<h1 id="explainable-artificial-intelligence">Explainable Artificial Intelligence<a hidden class="anchor" aria-hidden="true" href="#explainable-artificial-intelligence">#</a></h1>
<p>I borrow the name of this section from the DARPA project <a href="https://www.darpa.mil/program/explainable-artificial-intelligence">&ldquo;Explainable Artificial Intelligence&rdquo;</a>. This Explainable AI (XAI) program aims to develop more interpretable models and to enable human to understand, appropriately trust, and effectively manage the emerging generation of artificially intelligent techniques.</p>
<p>With the progress of the deep learning applications, people start worrying about that <a href="https://www.technologyreview.com/s/601860/if-a-driverless-car-goes-bad-we-may-never-know-why/">we may never know even if the model goes bad</a>. The complicated structure, the large number of learnable parameters, the nonlinear mathematical operations and <a href="https://arxiv.org/abs/1312.6199">some intriguing properties</a> (Szegedy et al., 2014) lead to the un-interpretability of deep neural networks, creating a true black-box. Although the power of deep learning is originated from this complexity &mdash; more flexible to capture rich and intricate patterns in the real-world data.</p>
<p>Studies on <strong>adversarial examples</strong> (<a href="https://blog.openai.com/robust-adversarial-inputs/">OpenAI Blog: Robust Adversarial Examples</a>, <a href="https://blog.openai.com/adversarial-example-research/">Attacking Machine Learning with Adversarial Examples</a>, <a href="https://arxiv.org/pdf/1412.6572.pdf">Goodfellow, Shlens &amp; Szegedy, 2015</a>; <a href="http://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Nguyen_Deep_Neural_Networks_2015_CVPR_paper.pdf">Nguyen, Yosinski, &amp; Clune, 2015</a>) raise the alarm on the robustness and safety of AI applications. Sometimes the models could show unintended, unexpected and unpredictable behavior and we have no fast/good strategy to tell why.</p>
<img src="adversarial_examples.png" class="center" />
<figcaption>Fig. 7. Illustrations of adversarial examples. (a-d) are adversarial images that are generated by adding human-imperceptible noises onto original images (<a href="https://arxiv.org/abs/1312.6199" target="_blank">Szegedy et al., 2013</a>). A well-trained neural network model can successfully classify original ones but fail adversarial ones. (e-h) are patterns that are generated (<a href="http://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Nguyen_Deep_Neural_Networks_2015_CVPR_paper.pdf" target="_blank">Nguyen, Yosinski & Clune, 2015</a>). A well-trained neural network model labels them into (e) school bus, (f) guitar, (g) peacock and (h) Pekinese respectively. (Image source: <a href="https://arxiv.org/pdf/1702.07800.pdf" target="_blank">Wang, Raj & Xing, 2017</a>)</figcaption>
<p>Nvidia recently developed <a href="https://blogs.nvidia.com/blog/2017/04/27/how-nvidias-neural-net-makes-decisions/">a method to visualize the most important pixel points</a> in their self-driving cars&rsquo; decisioning process. The visualization provides insights on how AI thinks and what the system relies on while operating the car. If what the AI believes to be important agrees with how human make similar decisions, we can naturally gain more confidence in the black-box model.</p>
<p>Many exciting news and findings are happening in this evolving field every day. Hope my post can give you some pointers and encourage you to investigate more into this topic :)</p>
<hr>
<p>Cited as:</p>
<pre tabindex="0"><code>@article{weng2017gan,
  title   = &#34;How to Explain the Prediction of a Machine Learning Model?&#34;,
  author  = &#34;Weng, Lilian&#34;,
  journal = &#34;lilianweng.github.io&#34;,
  year    = &#34;2017&#34;,
  url     = &#34;https://lilianweng.github.io/posts/2017-08-01-interpretation/&#34;
}
</code></pre><h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Zachary C. Lipton. <a href="https://arxiv.org/pdf/1606.03490.pdf">&ldquo;The mythos of model interpretability.&rdquo;</a> arXiv preprint arXiv:1606.03490 (2016).</p>
<p>[2] Been Kim, Rajiv Khanna, and Oluwasanmi O. Koyejo. &ldquo;Examples are not enough, learn to criticize! criticism for interpretability.&rdquo; Advances in Neural Information Processing Systems. 2016.</p>
<p>[3] Himabindu Lakkaraju, Stephen H. Bach, and Jure Leskovec. <a href="http://www.kdd.org/kdd2016/papers/files/rpp1067-lakkarajuA.pdf">&ldquo;Interpretable decision sets: A joint framework for description and prediction.&rdquo;</a> Proc. 22nd ACM SIGKDD Intl. Conf. on Knowledge Discovery and Data Mining. ACM, 2016.</p>
<p>[4] Robnik-Šikonja, Marko, and Igor Kononenko. <a href="http://lkm.fri.uni-lj.si/rmarko/papers/RobnikSikonjaKononenko08-TKDE.pdf">&ldquo;Explaining classifications for individual instances.&rdquo;</a> IEEE Transactions on Knowledge and Data Engineering 20.5 (2008): 589-600.</p>
<p>[5] Baehrens, David, et al. <a href="http://www.jmlr.org/papers/volume11/baehrens10a/baehrens10a.pdf">&ldquo;How to explain individual classification decisions.&rdquo;</a> Journal of Machine Learning Research 11.Jun (2010): 1803-1831.</p>
<p>[6] Marco Tulio Ribeiro, Sameer Singh, and Carlos Guestrin. <a href="https://arxiv.org/pdf/1602.04938.pdf">&ldquo;Why should I trust you?: Explaining the predictions of any classifier.&rdquo;</a> Proc. 22nd ACM SIGKDD Intl. Conf. on Knowledge Discovery and Data Mining. ACM, 2016.</p>
<p>[7] Yiming Yang, and Jan O. Pedersen. <a href="http://www.surdeanu.info/mihai/teaching/ista555-spring15/readings/yang97comparative.pdf">&ldquo;A comparative study on feature selection in text categorization.&rdquo;</a> Intl. Conf. on Machine Learning. Vol. 97. 1997.</p>
<p>[8] Isabelle Guyon, and André Elisseeff. <a href="http://www.jmlr.org/papers/volume3/guyon03a/guyon03a.pdf">&ldquo;An introduction to variable and feature selection.&rdquo;</a> Journal of Machine Learning Research 3.Mar (2003): 1157-1182.</p>
<p>[9] Ian J. Goodfellow, Jonathon Shlens, and Christian Szegedy. <a href="https://arxiv.org/pdf/1412.6572.pdf">&ldquo;Explaining and harnessing adversarial examples.&rdquo;</a>  ICLR 2015.</p>
<p>[10] Christian Szegedy, Wojciech Zaremba, Ilya Sutskever, Joan Bruna, Dumitru Erhan, Ian Goodfellow, Rob Fergus. <a href="https://arxiv.org/abs/1312.6199">&ldquo;Intriguing properties of neural networks.&rdquo;</a> Intl. Conf. on Learning Representations (2014)</p>
<p>[11] Nguyen, Anh, Jason Yosinski, and Jeff Clune. <a href="http://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Nguyen_Deep_Neural_Networks_2015_CVPR_paper.pdf">&ldquo;Deep neural networks are easily fooled: High confidence predictions for unrecognizable images.&rdquo;</a> Proc. IEEE Conference on Computer Vision and Pattern Recognition. 2015.</p>
<p>[12] Benjamin Letham, Cynthia Rudin, Tyler H. McCormick, and David Madigan. <a href="https://arxiv.org/abs/1511.01644">&ldquo;Interpretable classifiers using rules and Bayesian analysis: Building a better stroke prediction model.&rdquo;</a> The Annals of Applied Statistics 9, No. 3 (2015): 1350-1371.</p>
<p>[13] Haohan Wang, Bhiksha Raj, and Eric P. Xing. <a href="https://arxiv.org/pdf/1702.07800.pdf">&ldquo;On the Origin of Deep Learning.&rdquo;</a> arXiv preprint arXiv:1702.07800 (2017).</p>
<p>[14] <a href="https://blog.openai.com/robust-adversarial-inputs/">OpenAI Blog: Robust Adversarial Examples</a></p>
<p>[15] <a href="https://blog.openai.com/adversarial-example-research/">Attacking Machine Learning with Adversarial Examples</a></p>
<p>[16] <a href="https://blogs.nvidia.com/blog/2017/04/27/how-nvidias-neural-net-makes-decisions/">Reading an AI Car’s Mind: How NVIDIA’s Neural Net Makes Decisions</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lilianweng.github.io/tags/foundation/">foundation</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lilianweng.github.io/posts/2017-08-20-gan/">
    <span class="title">« </span>
    <br>
    <span>From GAN to WGAN</span>
  </a>
  <a class="next" href="https://lilianweng.github.io/posts/2017-07-22-stock-rnn-part-2/">
    <span class="title"> »</span>
    <br>
    <span>Predict Stock Prices Using RNN: Part 2</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on twitter"
        href="https://twitter.com/intent/tweet/?text=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f&amp;hashtags=foundation">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f&amp;title=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f&amp;summary=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f&amp;source=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f&title=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on whatsapp"
        href="https://api.whatsapp.com/send?text=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f%20-%20https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Explain the Prediction of a Machine Learning Model? on telegram"
        href="https://telegram.me/share/url?text=How%20to%20Explain%20the%20Prediction%20of%20a%20Machine%20Learning%20Model%3f&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2017-08-01-interpretation%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://lilianweng.github.io/">Lil&#39;Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
