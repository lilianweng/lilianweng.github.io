<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to Build an Open-Domain Question Answering System? | Lil&#39;Log</title>
<meta name="keywords" content="nlp, language-model, attention, transformer" />
<meta name="description" content="[Updated on 2020-11-12: add an example on closed-book factual QA using OpenAI API (beta).
A model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.
Disclaimers given so many papers in the wild:">
<meta name="author" content="Lilian Weng">
<link rel="canonical" href="https://lilianweng.github.io/posts/2020-10-29-odqa/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.67a6fb6e33089cb29e856bcc95d7aa39f70049a42b123105531265a0d9f1258b.css" integrity="sha256-Z6b7bjMInLKehWvMldeqOfcASaQrEjEFUxJloNnxJYs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js" integrity="sha256-W5rgME&#43;T22zEk/UYRvASQorzmcYUtPL723&#43;lndTV71s="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lilianweng.github.io/favicon_peach.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lilianweng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lilianweng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lilianweng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lilianweng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HFT45VFBX6"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-HFT45VFBX6', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="How to Build an Open-Domain Question Answering System?" />
<meta property="og:description" content="[Updated on 2020-11-12: add an example on closed-book factual QA using OpenAI API (beta).
A model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.
Disclaimers given so many papers in the wild:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lilianweng.github.io/posts/2020-10-29-odqa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-29T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-10-29T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to Build an Open-Domain Question Answering System?"/>
<meta name="twitter:description" content="[Updated on 2020-11-12: add an example on closed-book factual QA using OpenAI API (beta).
A model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.
Disclaimers given so many papers in the wild:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lilianweng.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to Build an Open-Domain Question Answering System?",
      "item": "https://lilianweng.github.io/posts/2020-10-29-odqa/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to Build an Open-Domain Question Answering System?",
  "name": "How to Build an Open-Domain Question Answering System?",
  "description": "[Updated on 2020-11-12: add an example on closed-book factual QA using OpenAI API (beta).\nA model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.\nDisclaimers given so many papers in the wild:",
  "keywords": [
    "nlp", "language-model", "attention", "transformer"
  ],
  "articleBody": " [Updated on 2020-11-12: add an example on closed-book factual QA using OpenAI API (beta).\nA model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.\nDisclaimers given so many papers in the wild:\nAssume we have access to a powerful pretrained language model. We do not cover how to use structured knowledge base (e.g. Freebase, WikiData) here. We only focus on a single-turn QA instead of a multi-turn conversation style QA. We mostly focus on QA models that contain neural networks, specially Transformer-based language models. I admit that I missed a lot of papers with architectures designed specifically for QA tasks between 2017-2019üòî What is Open-Domain Question Answering? Open-domain Question Answering (ODQA) is a type of language tasks, asking a model to produce answers to factoid questions in natural language. The true answer is objective, so it is simple to evaluate model performance.\nFor example,\nQuestion: What did Albert Einstein win the Nobel Prize for? Answer: The law of the photoelectric effect. The ‚Äúopen-domain‚Äù part refers to the lack of the relevant context for any arbitrarily asked factual question. In the above case, the model only takes as the input the question but no article about ‚Äúwhy Einstein didn‚Äôt win a Nobel Prize for the theory of relativity‚Äù is provided, where the term ‚Äúthe law of the photoelectric effect‚Äù is likely mentioned. In the case when both the question and the context are provided, the task is known as Reading comprehension (RC).\nAn ODQA model may work with or without access to an external source of knowledge (e.g. Wikipedia) and these two conditions are referred to as open-book or closed-book question answering, respectively.\nWhen considering different types of open-domain questions, I like the classification by Lewis, et al., 2020, in increasing order of difficulty:\nA model is able to correctly memorize and respond with the answer to a question that has been seen at training time. A model is able to answer novel questions at test time and choose an answer from the set of answers it has seen during training. A model is able to answer novel questions which have answers not contained in the training dataset. Fig. 1. Overview of three frameworks discussed in this post. Notation Given a question $x$ and a ground truth answer span $y$, the context passage containing the true answer is labelled as $z \\in \\mathcal{Z}$, where $\\mathcal{Z}$ is an external knowledge corpus. Wikipedia is a common choice for such an external knowledge source.\nConcerns of QA data fine-tuning Before we dive into the details of many models below. I would like to point out one concern of fine-tuning a model with common QA datasets, which appears as one fine-tuning step in several ODQA models. It could be concerning, because there is a significant overlap between questions in the train and test sets in several public QA datasets.\nLewis, et al., (2020) (code) found that 58-71% of test-time answers are also present somewhere in the training sets and 28-34% of test-set questions have a near-duplicate paraphrase in their corresponding training sets. In their experiments, several models performed notably worse when duplicated or paraphrased questions were removed from the training set.\nOpen-book QA: Retriever-Reader Given a factoid question, if a language model has no context or is not big enough to memorize the context which exists in the training dataset, it is unlikely to guess the correct answer. In an open-book exam, students are allowed to refer to external resources like notes and books while answering test questions. Similarly, a ODQA system can be paired with a rich knowledge base to identify relevant documents as evidence of answers.\nWe can decompose the process of finding answers to given questions into two stages,\nFind the related context in an external repository of knowledge; Process the retrieved context to extract an answer. Fig. 2. The retriever-reader QA framework combines information retrieval with machine reading comprehension. Such a retriever + reader framework was first proposed in DrQA (‚ÄúDocument retriever Question-Answering‚Äù by Chen et al., 2017; code). The retriever and the reader components can be set up and trained independently, or jointly trained end-to-end.\nRetriever Model Two popular approaches for implementing the retriever is to use the information retrieval (IR) system that depends on (1) the classic non-learning-based TF-IDF features (‚Äúclassic IR‚Äù) or (2) dense embedding vectors of text produced by neural networks (‚Äúneural IR‚Äù).\nClassic IR DrQA (Chen et al., 2017) adopts an efficient non-learning-based search engine based on the vector space model. Every query and document is modelled as a bag-of-word vector, where each term is weighted by TF-IDF (term frequency $\\times$ inverse document frequency).\n$$ \\begin{aligned} \\text{tf-idf}(t, d, \\mathcal{D}) \u0026= \\text{tf}(t, d) \\times \\text{idf}(t, \\mathcal{D}) \\\\ \\text{tf}(t, d) \u0026= \\log(1 + \\text{freq}(t, d)) \\\\ \\text{idf}(t, \\mathcal{D}) \u0026= \\log \\Big( \\frac{\\vert\\mathcal{D}\\vert}{\\vert d\\in\\mathcal{D}: t\\in d\\vert} \\Big) \\end{aligned} $$ where $t$ is a unigram or bigram term in a document $d$ from a collection of documents $\\mathcal{D}$ . $\\text{freq}(t, d)$ measures how many times a term $t$ appears in $d$. Note that the term-frequency here includes bigram counts too, which is found to be very helpful because the local word order is taken into consideration via bigrams. As part of the implementation, DrQA maps the bigrams of $2^{24}$ bins using unsigned murmur3 hash.\nPrecisely, DrQA implemented Wikipedia as its knowledge source and this choice has became a default setting for many ODQA studies since then. The non-ML document retriever returns the top $k=5$ most relevant Wikipedia articles given a question.\nBERTserini (Yang et al., 2019) pairs the open-source Anserini IR toolkit as the retriever with a fine-tuned pre-trained BERT model as the reader. The top $k$ documents ($k=10$) are retrieved via the post-v3.0 branch of Anserini with the query treated as a bag of words. The retrieved text segments are ranked by BM25, a classic TF-IDF-based retrieval scoring function. In terms of the effect of text granularity on performance, they found that paragraph retrieval \u003e sentence retrieval \u003e article retrieval.\nFig. 3. An illustration of BERTserini architecture. (Image source: Yang et al., 2019) ElasticSearch + BM25 is used by the Multi-passage BERT QA model (Wang et al., 2019). They found that splitting articles into passages with the length of 100 words by sliding window brings 4% improvements, since splitting documents into passages without overlap may cause some near-boundary evidence to lose useful contexts.\nNeural IR There is a long history in learning a low-dimensional representation of text, denser than raw term-based vectors (Deerwester et al., 1990; Yih, et al., 2011). Dense representations can be learned through matrix decomposition or some neural network architectures (e.g. MLP, LSTM, bidirectional LSTM, etc). When involving neural networks, such approaches are referred to as ‚ÄúNeural IR‚Äù, Neural IR is a new category of methods for retrieval problems, but it is not necessary to perform better/superior than classic IR (Lim, 2018).\nAfter the success of many large-scale general language models, many QA models embrace the following approach:\n$$ h_x = E_x(x)\\quad h_z = E_z(z)\\quad \\text{score}(x, z) = h_x^\\top h_z $$ Extract the dense representations of a question $x$ and a context passage $z$ by feeding them into a language model; Use the dot-product of these two representations as the retrieval score to rank and select most relevant passages. ORQA, REALM and DPR all use such a scoring function for context retrieval, which will be described in detail in a later section on the end-to-end QA model.\nAn extreme approach, investigated by DenSPI (‚ÄúDense-Sparse Phrase Index‚Äù; Seo et al., 2019), is to encode all the text in the knowledge corpus at the phrase level and then only rely on the retriever to identify the most relevant phrase as the predicted answer. In this way, the retriever+reader pipeline is reduced to only retriever. Of course, the index would be much larger and the retrieval problem is more challenging.\nDenSPI introduces a query-agnostic indexable representation of document phrases. Precisely it encodes query-agnostic representations of text spans in Wikipedia offline and looks for the answer at inference time by performing nearest neighbor search. It can drastically speed up the inference time, because there is no need to re-encode documents for every new query, which is often required by a reader model.\nGiven a question $x$ and a fixed set of (Wikipedia) documents, $z_1, \\dots, z_K$ and each document $z_k$ contains $N_k$ words, $z_k = \\langle z_k^{(1)}, \\dots, z_k^{(N_k)}\\rangle$. An ODQA model is a scoring function $F$ for each candidate phrase span $z_k^{(i:j)}, 1 \\leq i \\leq j \\leq N_k$, such that the truth answer is the phrase with maximum score: $y = {\\arg\\max}_{k,i,j} F(x, z_k^{(i:j)})$.\nThe phrase representation $z_k^{(i:j)}$ combines both dense and sparse vectors, $z_k^{(i:j)} = [d_k^{(i:j)}, s_k^{(i:j)}] \\in \\mathbb{R}^{d^d + d^s}$ (note that $d^d \\ll d^s$):\nThe dense vector $d_k^{(i:j)}$ is effective for encoding local syntactic and semantic cues, as what can be learned by a pretrained language model. The sparse vector $s_k^{(i:j)}$ is superior at encoding precise lexical information. The sparse vector is term-frequency-based encoding. DenSPI uses 2-gram term-frequency same as DrQA, resulting a highly sparse representation ($d^s \\approx 16$M) The dense vector $d^{(i:j)}$ is further decomposed into three parts, $d^{(i:j)} = [a_i, b_j, c_{ij}] \\in \\mathbb{R}^{2d^b + 1}$ where $2d^b + 1 = d^d$. All three components are learned based on different columns of the fine-tuned BERT representations.\nA vector $a_i$ encodes the start position for the $i$-th word of the document; A vector $b_j$ encodes the end position for the $j$-th word of the document; A scalar $c_{ij}$ measures the coherency between the start and the end vectors, helping avoid non-constituent phrases during inference. For all possible $(i,j,k)$ tuples where $j-i \u003c J$, the text span embeddings are precomputed and stored as a phrase index. The maximum span length $J$ is a predefined scalar constant.\nFig. 4. An illustration of Dense-Sparse Phrase Index (DenSPI) architecture. (Image source: Seo et al., 2019) At the inference time, the question is mapped into the same vector space $x=[d‚Äô, s‚Äô] \\in \\mathbb{R}^{d^d + d^s}$, where the dense vector $d‚Äô$ is extracted from the BERT embedding of the special [CLS] symbol. The same BERT model is shared for encoding both questions and phrases. The final answer is predicted by $k^*, i^*, j^* = \\arg\\max x^\\top z_k^{(i:j)}$.\nReader Model The reader model learns to solve the reading comprehension task ‚Äî extract an answer for a given question from a given context document. Here we only discuss approaches for machine comprehension using neural networks.\nBi-directional LSTM The reader model for answer detection of DrQA (Chen et al., 2017) is a 3-layer bidirectional LSTM with hidden size 128. Every relevant paragraph of retrieved Wikipedia articles is encoded by a sequence of feature vector, $\\{\\tilde{\\mathbf{z}}_1, \\dots, \\tilde{\\mathbf{z}}_m \\}$. Each feature vector $\\hat{\\mathbf{z}}_i \\in \\mathbb{R}^{d_z}$ is expected to capture useful contextual information around one token $z_i$. The feature consists of several categories of features:\nWord embeddings: A 300d Glove word embedding trained from 800B Web crawl data, $f_\\text{embed} = E_g(z_i)$. Exact match: Whether a word $z_i$ appears in the question $x$, $f_\\text{match} = \\mathbb{I}(z_i \\in x)$. Token features: This includes POS (part-of-speech) tagging, NER (named entity recognition), and TF (term-frequency), $f_\\text{token}(z_i) = (\\text{POS}(z_i), \\text{NER}(z_i), \\text{TF}(z_i))$. Aligned question embedding: The attention score $y_{ij}$ is designed to capture inter-sentence matching and similarity between the paragraph token $z_i$ and the question word $x_j$. This feature adds soft alignments between similar but non-identical words. $$ \\begin{aligned} f_\\text{align}(z_i) \u0026= \\sum_j y_{i,j} E_g(x_j) \\\\ y_{i,j} \u0026= \\frac{\\exp(\\alpha(E_g(z_i))^\\top \\alpha(E_g(x_j)) )}{\\sum_{j'} \\exp(\\alpha(E_g(z_i))^\\top \\alpha(E_g(x_{j'})) ) } \\end{aligned} $$ where $\\alpha$ is a single dense layer with ReLU and $E_g(.)$ is the glove word embedding.\nThe feature vector of a paragraph of $m$ tokens is fed into LSTM to obtain the final paragraph vectors:\n$$ \\begin{aligned} \\mathbf{z} = \\{\\mathbf{z}_1, \\dots, \\mathbf{z}_m\\} \u0026= \\text{LSTM}(\\{\\tilde{\\mathbf{z}}_1, \\dots, \\tilde{\\mathbf{z}}_m\\}) \\\\ \\text{where } \\tilde{\\mathbf{z}}_i \u0026= \\{f_\\text{embed}, f_\\text{match}, f_\\text{token}, f_\\text{align}\\} \\end{aligned} $$ The question is encoded as a weighted sum of the embeddings of every word in the question:\n$$ \\mathbf{x} = \\sum_j b_j E(x_j) \\quad b_j = \\text{softmax}(\\mathbf{w}^\\top E(x_j)) $$ where $\\mathbf{w}$ is a weight vector to learn.\nOnce the feature vectors are constructed for the question and all the related paragraphs, the reader needs to predict the probabilities of each position in a paragraph to be the start and the end of an answer span, $p_\\text{start}(i_s)$ and $p_\\text{end}(i_s)$, respectively. Across all the paragraphs, the optimal span is returned as the final answer with maximum $p_\\text{start}(i_s) \\times p_\\text{end}(i_e) $.\n$$ \\begin{aligned} p_\\text{start}(i_s) \\propto \\exp(\\mathbf{z}_{i_s} \\mathbf{W}_s \\mathbf{x}) \\\\ p_\\text{end}(i_e) \\propto \\exp(\\mathbf{z}_{i_e} \\mathbf{W}_e \\mathbf{x}) \\\\ \\text{ s.t. } i_s \\leq i_e \\leq i_s + 15 \\end{aligned} $$ where $\\mathbf{W}_s$ and $\\mathbf{W}_e$ are learned parameters.\nBERT-universe Following the success of BERT (Devlin et al., 2018), many QA models develop the machine comprehension component based on BERT. Let‚Äôs define the BERT model as a function that can take one or multiple strings (concatenated by [SEP]) as input and outputs a set of BERT encoding vectors for the special [CLS] token and every input token:\n$$ \\text{BERT}(s_1, s_2, \\dots) = [\\mathbf{h}^\\texttt{[CLS]}, \\mathbf{h}^{(1)}, \\mathbf{h}^{(2)}, \\dots] $$ where $\\mathbf{h}^\\texttt{[CLS]}$ is the embedding vector for the special [CLS] token and $\\mathbf{h}^{(i)}$ is the embedding vector for the $i$-th token.\nTo use BERT for reading comprehension, it learns two additional weights, $\\mathbf{W}_s$ and $\\mathbf{W}_e$, and $\\text{softmax}(\\mathbf{h}^{(i)}\\mathbf{W}_s)$ and $\\text{softmax}(\\mathbf{h}^{(i)}\\mathbf{W}_e)$ define two probability distributions of start and end position of the predicted span per token.\nBERTserini (Yang et al., 2019) utilizes a pre-trained BERT model to work as the reader. Their experiments showed that fine-tuning pretrained BERT with SQuAD is sufficient to achieve high accuracy in identifying answer spans.\nFig. 5. How BERT is used to solve question-answering tasks. (Image source: Devlin et al., 2018) The key difference of the BERTserini reader from the original BERT is: to allow comparison and aggregation of results from different segments, the final softmax layer over different answer spans is removed. The pre-trained BERT model is fine-tuned on the training set of SQuAD, where all inputs to the reader are padded to 384 tokens with the learning rate 3e-5.\nWhen ranking all the extracted answer spans, the retriever score (BM25) and the reader score (probability of token being the start position $\\times$ probability of the same token being the end position ) are combined via linear interpolation.\nThe original BERT normalizes the probability distributions of start and end position per token for every passage independently. Differently, the Multi-passage BERT (Wang et al., 2019) normalizes answer scores across all the retrieved passages of one question globally. Precisely, multi-passage BERT removes the final normalization layer per passage in BERT for QA (same as in BERTserini) and then adds a global softmax over all the word positions of all the passages. Global normalization makes the reader model more stable while pin-pointing answers from a large number of passages.\nIn addition, multi-passage BERT implemented an independent passage ranker model via another BERT model and the rank score for $(x, z)$ is generated by a softmax over the representation vectors of the first [CLS] token. The passage ranker brings in extra 2% improvements. Similar idea of re-ranking passages with BERT was discussed in Nogueira \u0026 Cho, 2019, too.\nInterestingly, Wang et al., 2019 found that explicit inter-sentence matching does not seem to be critical for RC tasks with BERT; check the original paper for how the experiments were designed. One possible reason is that the multi-head self-attention layers in BERT has already embedded the inter-sentence matching.\nEnd-to-end Joint Training The retriever and reader components can be jointly trained. This section covers R^3, ORQA, REALM and DPR. There are a lot of common designs, such as BERT-based dense vectors for retrieval and the loss function on maximizing the marginal likelihood of obtaining true answers.\nThe retriever and reader models in the R^3 (‚ÄúReinforced Ranker-Reader‚Äù; Wang, et al., 2017) QA system are jointly trained via reinforcement learning. (Note that to keep the term consistent between papers in this section, the ‚Äúranker‚Äù model in the original R^3 paper is referred to as the ‚Äúretriever‚Äù model here.) Both components are variants of Match-LSTM, which relies on an attention mechanism to compute word similarities between the passage and question sequences.\nHow does the Match-LSTM module work? Given a question $\\mathbf{X}$ of $d_x$ words and a passage $\\mathbf{Z}$ of $d_z$ words, both representations use fixed Glove word embeddings,\n$$ \\begin{aligned} \\mathbf{H}^x \u0026= \\text{BiLSTM}(\\mathbf{X}) \\in \\mathbb{R}^{l \\times d_x} \\\\ \\mathbf{H}^z \u0026= \\text{BiLSTM}(\\mathbf{Z}) \\in \\mathbb{R}^{l \\times d_z} \\\\ \\mathbf{G} \u0026= \\text{softmax}((\\mathbf{W}^g \\mathbf{H}^x + \\mathbf{b}^g \\otimes \\mathbf{e}_{d_x})^\\top \\mathbf{H}^z) \\in \\mathbb{R}^{d_x \\times d_z} \u0026 \\text{; an attention matrix}\\\\ \\bar{\\mathbf{H}}^x \u0026= \\mathbf{H}^x \\mathbf{G} \\in \\mathbb{R}^{l \\times d_z} \\\\ \\mathbf{M} \u0026= \\text{ReLU} \\Big( \\mathbf{W}^m \\begin{bmatrix} \\mathbf{H}^z \\\\ \\bar{\\mathbf{H}}^x \\\\ \\mathbf{H}^z \\odot \\bar{\\mathbf{H}}^x \\\\ \\mathbf{H}^z - \\bar{\\mathbf{H}}^x \\end{bmatrix} \\Big) \\in \\mathbb{R}^{2l \\times d_z} \\\\ \\mathbf{H}^m \u0026= \\text{BiLSTM}(M) \\in \\mathbb{R}^{l \\times d_z} \\end{aligned} $$ where $l$ is the hidden dimension of the bidirectional LSTM module. $\\mathbf{W}^g \\in \\mathbb{R}^{l\\times l}$, $\\mathbf{b}^g \\in \\mathbb{R}^l$, and $\\mathbf{W}^m \\in \\mathbb{R}^{2l \\times 4l}$ are parameters to learn. The operator $\\otimes \\mathbf{e}_{d_x}$ is the outer product to repeat the column vector $\\mathbf{b}^g$ $d_x$ times.\nThe ranker and reader components share the same Match-LSTM module with two separate prediction heads in the last layer, resulting in $\\mathbf{H}^\\text{rank}$ and $\\mathbf{H}^\\text{reader}$.\nFig. 6. The overview of R^3 (reinforced ranker-reader) architecture. Both components share the same Match-LSTM module. (Image source: Wang, et al., 2017) The retriever runs a max-pooling operation per passage and then aggregates to output a probability of each passage entailing the answer.\n$$ \\begin{aligned} \\mathbf{u}_i \u0026= \\text{max-pooling}(\\mathbf{H}^\\text{rank}_i) \\in \\mathbb{R}^l \\\\ \\mathbf{C} \u0026= \\text{tanh}(\\mathbf{W}^c[\\mathbf{u}_1;\\dots;\\mathbf{u}_N] + \\mathbf{b}^c \\otimes \\mathbf{e}_N) \\in \\mathbb{R}^{l \\times n} \\\\ \\gamma \u0026= \\text{softmax}(\\mathbf{w}^c \\mathbf{C}) \\in \\mathbb{R}^n \\end{aligned} $$ Finally, the retriever is viewed as a policy to output action to sample a passage according to predicted $\\gamma$,\n$$ \\pi(z \\vert x; \\theta^\\gamma) = \\gamma_z $$ The reader predicts the start position $\\beta^s$ and the end position $\\beta^e$ of the answer span. Two positions are computed in the same way, with independent parameters to learn. There are $V$ words in all the passages involved.\n$$ \\begin{aligned} \\mathbf{H}^\\text{read} \u0026= [\\mathbf{H}^\\text{read}_\\tau; \\mathbf{H}^\\text{read}_{\\text{neg}_1}; \\dots; \\mathbf{H}^\\text{read}_{\\text{neg}_n}] \\\\ \\mathbf{F}^s \u0026= \\text{tanh}(\\mathbf{W}^s \\mathbf{H}^\\text{read} + \\mathbf{b}^s \\otimes \\mathbf{e}_V) \\quad \\beta^s = \\text{softmax}(\\mathbf{w}^s \\mathbf{F}^s) \\in \\mathbb{R}^V \\\\ \\mathbf{F}^e \u0026= \\text{tanh}(\\mathbf{W}^e \\mathbf{H}^\\text{read} + \\mathbf{b}^e \\otimes \\mathbf{e}_V) \\quad \\beta^e = \\text{softmax}(\\mathbf{w}^e \\mathbf{F}^e) \\in \\mathbb{R}^V \\\\ L(y \\vert z, x) \u0026= -\\log(\\beta^s_{y_z^s})-\\log(\\beta^e_{y_z^e}) \\end{aligned} $$ where $y$ is the ground-truth answer and the passage $z$ is sampled by the retriever. $\\beta^s_{y_z^s}$ and $\\beta^s_{y_z^e}$ represent the probabilities of the start and end positions of $y$ in passage $z$.\nThe training objective for the end-to-end R^3 QA system is to minimize the negative log-likelihood of obtaining the correct answer $y$ given a question $x$,\n$$ \\begin{aligned} \\mathcal{J}(\\theta) \u0026= -\\mathbb{E}_{z\\sim\\pi(.\\vert x)} [L(y \\vert z, x)] \\\\ \\nabla \\mathcal{J}(\\theta) \u0026= - \\nabla_\\theta \\sum_z \\pi(z \\vert x) L(y \\vert z, x) \\\\ \u0026= - \\sum_z \\big( L(y \\vert z, x) \\nabla_\\theta\\pi(z \\vert x) + \\pi(z \\vert x) \\nabla_\\theta L(y \\vert z, x) \\big) \\\\ \u0026= - \\mathbb{E}_{z\\sim\\pi(.\\vert x)} \\big( \\color{red}{L(y \\vert z, x)\\nabla_\\theta\\log\\pi(z \\vert x)} + \\nabla_\\theta L(y \\vert z, x) \\big) \\\\ \u0026\\approx - \\mathbb{E}_{z\\sim\\pi(.\\vert x)} \\big( \\underbrace{\\color{red}{R(y \\vert z, x)\\nabla_\\theta\\log\\pi(z \\vert x)}}_\\text{REINFORCE} + \\nabla_\\theta L(y \\vert z, x) \\big) \\end{aligned} $$ Essentially in training, given a passage $z$ sampled by the retriever, the reader is trained by gradient descent while the retriever is trained by REINFORCE using $L(y \\vert z, x)$ as the reward function. However, $L(y \\vert z, x)$ is not bounded and may introduce a lot of variance. The paper replaces the reward with a customized scoring function by comparing the ground truth $y$ and the answer extracted by the reader $\\hat{y}$:\n$$ R(y, \\hat{y} \\vert z) = \\begin{cases} 2 \u0026 \\text{if } y = \\hat{y}\\\\ f1(y, \\hat{y}) \u0026 \\text{if } y \\cap \\hat{y} = \\varnothing \\\\ -1 \u0026 \\text{otherwise} \\end{cases} $$ Fig. 7. The workflow of R^3 training process. (Image source: acl2020-openqa-tutorial/slides/part4) ORQA (‚ÄúOpen-Retrieval Question-Answering‚Äù; Lee et al., 2019) jointly learns a retriever + reader QA model to optimize marginal log-likelihood of obtaining correct answers in a supervised manner. No explicit ‚Äúblack-box‚Äù IR system is involved. Instead, it is capable of retrieving any text in an open corpus. During training, ORQA does not need ground-truth context passages (i.e. reading comprehension datasets) but only needs (question, answer) string pairs. Both retriever and reader components are based on BERT, but not shared.\nFig. 8. An illustration of the retriever component in ORQA. (Image source: replotted based on one slide in acl2020-openqa-tutorial/slides/part5) All the evidence blocks are ranked by a retrieval score, defined as the inner product of BERT embedding vectors of the [CLS] token of the question $x$ and the evidence block $z$. Note that the encoders for questions and context are independent.\n$$ \\begin{aligned} h_x \u0026= \\mathbf{W}_x \\text{BERT}_x(x)^{\\mathtt{[CLS]}} \\\\ h_z \u0026= \\mathbf{W}_z \\text{BERT}_z(z)^{\\mathtt{[CLS]}} \\\\ S_\\text{retr}(z, x) \u0026= h_x^\\top h_z \\end{aligned} $$ The retriever module is pretrained with Inverse Cloze Task (ICT), which is to predict the context given a sentence, opposite to the standard Cloze Task. The ICT objective is to maximize the retrieval score of the correct context $z$ given a random sentence $x$:\n$$ L_\\text{ICT} = p_\\text{early}(z \\vert x) = \\frac{\\exp(S_\\text{retr}(z, x))}{\\sum_{z'\\in\\text{BATCH}(\\mathcal{Z})} \\exp(S_\\text{retr}(z', x))} $$ where $\\text{BATCH}(\\mathcal{Z})$ is the set of evidence blocks in the same batch used as sampled negatives.\nAfter such pretraining, the BERT retriever is expected to have representations good enough for evidence retrieval. Only the question encoder needs to be fine-tuned for answer extraction. In other words, the evidence block encoder (i.e., $\\mathbf{W}_z$ and $\\text{BERT}_z$) is fixed and thus all the evidence block encodings can be pre-computed with support for fast Maximum Inner Product Search (MIPS).\nFig. 9. An illustration of the reader component in ORQA. (Image source: acl2020-openqa-tutorial/slides/part5) The reader follows the same design as in the original BERT RC experiments. It learns in a supervised manner, while the parameters of the evidence block encoder are fixed and all other parameters are fine-tuned. Given a question $x$ and a gold answer string $y$, the reader loss contains two parts:\n$$ \\mathcal{L}(x, y) = \\mathcal{L}_\\text{early}(x, y) + \\mathcal{L}_\\text{full}(x, y) $$ (1) Find all correct text spans within top $k$ evidence blocks and optimize for the marginal likelihood of a text span $s$ that matches the true answer $y$:\n$$ \\begin{aligned} h_s \u0026= \\text{BERT}_R(x, y)^{(\\text{START}(s))} \\\\ h_e \u0026= \\text{BERT}_R(x, y)^{(\\text{END}(s))} \\\\ S_\\text{read}(z, s, x) \u0026= \\text{MLP}([h_s; h_e]) \\\\ p(z, s \\vert x) \u0026= \\frac{\\exp(S_\\text{read}(z, s, x))}{\\sum_{z'\\in\\text{TOP}(k)} \\sum_{s'\\in z'} \\exp(S_\\text{read}(z', s', x))} \\\\ L_\\text{full}(x, y) \u0026= - \\log \\sum_{\\substack{z \\in \\text{TOP}(k)\\\\ s \\in z}} \\sum_{y=\\text{TEXT}(s)} p(z, s \\vert x) \\end{aligned} $$ where $y=\\text{TEXT}(s)$ indicates whether the answer $y$ matches the text span $s$. $\\text{TOP}(k)$ is the top $k$ retrieved blocks according to $S_\\text{retr}(z, x)$. The paper sets $k=5$.\n(2) At the early stage of learning, when the retriever is not strong enough, it is possible none of the top $k$ blocks contains the answer. To avoid such sparse learning signals, ORQA considers a larger set of $c$ evidence blocks for more aggressive learning. The paper has $c=5000$.\n$$ L_\\text{early}(x, y) = -\\log \\sum_{\\substack{z\\in \\text{TOP}(c)\\\\y\\in\\text{TEXT}(z)}} p_\\text{early}(z\\vert x) = -\\log \\sum_{\\substack{z\\in \\text{TOP}(c)\\\\y\\in\\text{TEXT}(z)}} \\frac{\\exp(S_\\text{retr}(z, x)}{\\sum_{z'\\in\\text{TOP}(c)} \\exp(S_\\text{retr}(z', x)} $$ Some issues in SQuAD dataset were discussed in the ORQA paper:\n\" The notable drop between development and test accuracy for SQuAD is a reflection of an artifact in the dataset‚Äîits 100k questions are derived from only 536 documents. Therefore, good retrieval targets are highly correlated between training examples, violating the IID assumption, and making it unsuitable for learned retrieval. We strongly suggest that those who are interested in end-to-end open-domain QA models no longer train and evaluate with SQuAD for this reason.\"\nREALM (‚ÄúRetrieval-Augmented Language Model pre-training‚Äù; Guu et al., 2020) also jointly trains retriever + reader by optimizing the marginal likelihood of obtaining the true answer:\n$$ p(y \\vert x) = \\sum_{z \\in \\mathcal{Z}} \\underbrace{p(y \\vert x, z)}_\\text{reader} \\underbrace{p(z \\vert x)}_\\text{retriever} \\approx \\sum_{z \\in \\text{TOP}_k(\\mathcal{Z})} p(y \\vert x, z) p(z \\vert x) $$ Fig. 10. REALM is first unsupervised pre-trained with salient spans masking and then fine-tuned with QA data. (Image source: Guu et al., 2020). REALM computes two probabilities, $p(z \\vert x)$ and $p(y \\vert x, z)$, same as ORQA. However, different from ICT in ORQA, REALM upgrades the unsupervised pre-training step with several new design decisions, leading towards better retrievals. REALM pre-trains the model with Wikipedia or CC-News corpus.\nUse salient span masking. Named entities and dates are identified. Then one of these ‚Äúsalient spans‚Äù is selected and masked. Salient span masking is a special case of MLM and works out well for QA tasks. Add an empty null document. Because not every question demands a context document. No trivial retrieval. The context document should not be same as the selected sentence with a masked span. Apply the same ICT loss as in ORQA to encourage learning when the retrieval quality is still poor at the early stage of training. ‚ÄúAmong all systems, the most direct comparison with REALM is ORQA (Lee et al., 2019), where the fine-tuning setup, hyperparameters and training data are identical. The improvement of REALM over ORQA is purely due to better pre-training methods.‚Äù ‚Äî from REALM paper.\nBoth unsupervised pre-training and supervised fine-tuning optimize the same log-likelihood $\\log p(y \\vert x)$. Because the parameters of the retriever encoder for evidence documents are also updated in the process, the index for MIPS is changing. REALM asynchronously refreshes the index with the updated encoder parameters every several hundred training steps.\nBalachandran, et al. (2021) found that REALM is significantly undertrained and REALM++ achieves great EM accuracy improvement (3-5%) by scaling up the model training with larger batch size and more retrieved documents for the reader to process.\nDPR (‚ÄúDense Passage Retriever‚Äù; Karpukhin et al., 2020, code) argues that ICT pre-training could be too computationally expensive and the ORQA‚Äôs context encoder might be sub-optimal because it is not fine-tuned with question-answer pairs. DPR aims to resolve these two issues by only training a dense dual-encoder architecture for retrieval only from a small number of Q/A pairs, without any pre-training.\nSame as previous work, DPR uses the dot-product (L2 distance or cosine similarity also works) of BERT representations as retrieval score. The loss function for training the dual-encoder is the NLL of the positive passage, which essentially takes the same formulation as ICT loss of ORQA. Note that both of them consider other passages in the same batch as the negative samples, named in-batch negative sampling. The main difference is that DPR relies on supervised QA data, while ORQA trains with ICT on unsupervised corpus. At the inference time, DPR uses FAISS to run fast MIPS.\nDPR did a set of comparison experiments involving several different types of negatives:\nRandom: any random passage from the corpus; BM25: top passages returned by BM25 which don‚Äôt contain the answer but match most question tokens; In-batch negative sampling (‚Äúgold‚Äù): positive passages paired with other questions which appear in the training set. DPR found that using gold passages from the same mini-batch and one negative passage with high BM25 score works the best. To further improve the retrieval results, DPR also explored a setting where a BM25 score and a dense embedding retrieval score are linearly combined to serve as a new ranking function.\nOpen-book QA: Retriever-Generator Compared to the retriever-reader approach, the retriever-generator also has 2 stages but the second stage is to generate free text directly to answer the question rather than to extract start/end position in a retrieved passage. Some paper also refer to this as Generative question answering.\nFig. 11. The retriever + generator QA framework combines a document retrieval system with a general language model. A pretrained LM has a great capacity of memorizing knowledge in its parameters, as shown above. However, they cannot easily modify or expand their memory, cannot straightforwardly provide insights into their predictions, and may produce non-existent illusion.\nPetroni et al. (2020) studied how the retrieved relevant context can help a generative language model produce better answers. They found:\nAugmenting queries with relevant contexts dramatically improves the pretrained LM on unsupervised machine reading capabilities. An off-the-shelf IR system is sufficient for BERT to match the performance of a supervised ODQA baseline; BERT‚Äôs NSP pre-training strategy is a highly effective unsupervised mechanism in dealing with noisy and irrelevant contexts. They pair the BERT model with different types of context, including adversarial (unrelated context), retrieved (by BM25), and generative (by an autoregressive language model of 1.4N parameters, trained on CC-NEWS). The model is found to be robust to adversarial context, but only when the question and the context are provided as two segments (e.g. separated by [SEP]). One hypothesis is related to NSP task: ‚ÄúBERT might learn to not condition across segments for masked token prediction if the NSP score is low, thereby implicitly detecting irrelevant and noisy contexts.‚Äù\nRAG (‚ÄúRetrieval-Augmented Generation‚Äù; Lewis et al., 2020) combines pre-trained parametric (language model) and non-parametric memory (external knowledge index) together for language generation. RAG can be fine-tuned on any seq2seq task, whereby both the retriever and the sequence generator are jointly learned. They found that unconstrained generation outperforms previous extractive approaches.\nRAG consists of a retriever model $p_\\eta(z \\vert x)$ and a generator model $p_\\theta(y_i \\vert x, z, y_{1:i-1})$:\nThe retriever uses the input sequence $x$ to retrieve text passages $z$, implemented as a DPR retriever. $\\log p_\\eta(z \\vert x) \\propto E_z(z)^\\top E_x(x)$. The generator uses $z$ as additional context when generating the target sequence $y$, where the context and the question are simply concatenated. Depending on whether using the same or different retrieved documents for each token generation, there are two versions of RAG:\n$$ \\begin{aligned} p_\\text{RAG-seq}(y \\vert x) \u0026= \\sum_{z \\in \\text{TOP}_k(p_\\eta(.\\vert x))} p_\\eta(z \\vert x) \\prod_i^N p_\\theta(y_i \\vert x, z, y_{1:i-1}) \\\\ p_\\text{RAG-token}(y \\vert x) \u0026= \\prod_i^N \\sum_{z \\in \\text{TOP}_k(p_\\eta(.\\vert x))} p_\\eta(z_i\\vert x) p_\\theta(y_i \\vert x, z_i, y_{1:i-1}) \\end{aligned} $$ The retriever + generator in RAG is jointly trained to minimize the NLL loss, $\\mathcal{L}_\\text{RAG} = \\sum_j -\\log p(y_j \\vert x_j)$. Updating the passage encoder $E_z(.)$ is expensive as it requires the model to re-index the documents for fast MIPS. RAG does not find fine-tuning $E_z(.)$ necessary (like in ORQA) and only updates the query encoder + generator.\nFig. 12. An illustration of retrieval-augmented generation (RAG) architecture. (Image source: Lewis et al., 2020) At decoding/test time, RAG-token can be evaluated via a beam search. RAG-seq cannot be broken down into a set of per-token likelihood, so it runs beam search for each candidate document $z$ and picks the one with optimal $p_\\theta(y_i \\vert x, z, y_{1:i-1})$.\nThe Fusion-in-Decoder approach, proposed by Izacard \u0026 Grave (2020) is also based on a pre-trained T5. It works similar to RAG but differently for how the context is integrated into the decoder.\nRetrieve top $k$ related passage of 100 words each, using BM25 or DPR. Each retrieved passage and its title are concatenated with the question using special tokens like question:, title: and context: to indicate the content differences. Each retrieved passage is processed independently and later combined in the decoder. Processing passages independently in the encoder allows us to parallelize the computation. OTOH, processing them jointly encourages better aggregation of multiple pieces of evidence. The aggregation part is missing in extractive approaches. Note that they did fine-tune the pretrained LM independently for each dataset.\nClosed-book QA: Generative Language Model Big language models have been pre-trained on a large collection of unsupervised textual corpus. Given enough parameters, these models are able to memorize some factual knowledge within parameter weights. Therefore, we can use these models to do question-answering without explicit context, just like in a closed-book exam. The pre-trained language models produce free text to respond to questions, no explicit reading comprehension.\nFig. 13. The amount of computation used for training big language models of different sizes is getting big. (Image source: Brown et al., 2020). Roberts et al. (2020) measured the practical utility of a language model by fine-tuning a pre-trained model to answer questions without access to any external context or knowledge. They fine-tuned the T5 language model (same architecture as the original Transformer) to answer questions without inputting any additional information or context. Such setup enforces the language model to answer questions based on ‚Äúknowledge‚Äù that it internalized during pre-training.\nFig. 14. T5 is first pre-trained with salient span masking and then fine-tuned for each QA dataset to produce answers in free text. (Image source: Roberts et al. 2020) The original T5 models were pre-trained on a multi-task mixture including an unsupervised ‚Äúmasked language modeling‚Äù (MLM) tasks on the C4 (‚ÄúColossal Clean Crawled Corpus‚Äù) dataset as well as fine-tuned altogether with supervised translation, summarization, classification, and reading comprehension tasks. Roberts, et al. (2020) took a pre-trained T5 model and continued pre-training with salient span masking over Wikipedia corpus, which has been found to substantially boost the performance for ODQA. Then they fine-tuned the model for each QA datasets independently.\nWith a pre-trained T5 language model + continue pre-training with salient spans masking + fine-tuning for each QA dataset,\nIt can attain competitive results in open-domain question answering without access to external knowledge. A larger model can obtain better performance. For example, a T5 with 11B parameters is able to match the performance with DPR with 3 BERT-base models, each with 330M parameters. Interestingly, fine-tuning is not strictly necessary. GPT3 (Brown et al., 2020) has been evaluated on the closed book question answering task without any gradient updates or fine-tuning. During evaluation, the few-shot, one-shot and zero-shot settings here only refer to how many demonstrations are provided as context in the text input:\n‚Äúfew-shot learning‚Äù: GPT3 is allowed to take as many demonstrations as what can fit into the model‚Äôs context window (typically 10 to 100). ‚Äúone-shot learning‚Äù: only one demonstration is provided. ‚Äúzero-shot learning‚Äù: no demonstrations are allowed and only an instruction in natural language is given to the model. The performance grows with the model size. On the TriviaQA dataset, GPT3 evaluation with demonstrations can match or exceed the performance of SOTA baseline with fine-tuning.\nFig. 15. GPT3's performance on TriviaQA grows smoothly with the model size. More demonstrations lead to better performance. (Image source: Brown et al., 2020). Check out this cool example in OpenAI API playground viewer. The model is able to answer factal questions in short answer and not to make up things when the model does not know the answer. I added the last two questions and asked the model to respond with A:. The API is still in beta version, so you might need to apply to get on the wait list.\nQ: Who is Batman? A: Batman is a fictional comic book character. ## Q: What is torsalplexity? A: ? ## Q: What is Devz9? A: ? ## Q: Who is George Lucas? A: George Lucas is American film director and producer famous for creating Star Wars. ## Q: What is the capital of California? A: Sacramento. ## Q: What orbits the Earth? A: The Moon. ## Q: Who is Fred Rickerson? A: ? ## Q: What is an atom? A: An atom is a tiny particle that makes up everything. ## Q: Who is Alvan Muntz? A: ? ## Q: What is Kozar-09? A: ? ## Q: How many moons does Mars have? A: Two, Phobos and Deimos. ## Q: What is COVID-19? A: ? ## Q: What is H1N1? A: H1N1 is a strain of influenza. Related Techniques Fast Maximum Inner Product Search (MIPS) MIPS (maximum inner product search) is a crucial component in many open-domain question answering models. In retriever + reader/generator framework, a large number of passages from the knowledge source are encoded and stored in a memory. A retrieval model is able to query the memory to identify the top relevant passages which have the maximum inner product with the question‚Äôs embedding.\nWe need fast MIPS because the number of precomputed passage representations can be gigantic. There are several ways to achieve fast MIPS at run time, such as asymmetric LSH, data-dependent hashing, and FAISS.\nLanguage Model Pre-training Two pre-training tasks are especially helpful for QA tasks, as we have discussed above.\nInverse Cloze Task (proposed by ORQA): The goal of Cloze Task is to predict masked-out text based on its context. The prediction of Inverse Cloze Task (ICT) is in the reverse direction, aiming to predict the context given a sentence. In the context of QA tasks, a random sentence can be treated as a pseudo-question, and its context can be treated as pseudo-evidence.\nSalient Spans Masking (proposed by REALM): Salient span masking is a special case for MLM task in language model training. First, we find salient spans by using a tagger to identify named entities and a regular expression to identify dates. Then one of the detected salient spans is selected and masked. The task is to predict this masked salient span.\nSummary Model Retriever Reader / Generator Pre-training / Fine-tuning End2end DrQA TF-IDF Bi-directional LSTM ‚Äì No BERTserini Aserini + BM25 BERT without softmax layer Fine-tune with SQuAD No Multi-passage BERT ElasticSearch + BM25 Multi-passage BERT + Passage ranker No R^3 Classic IR + Match-LSTM Match-LSTM Yes ORQA Dot product of BERT embeddings BERT-RC Inverse cloze task Yes REALM Dot product of BERT embeddings BERT-RC Salient span masking Yes DPR Dot product of BERT embeddings BERT-RC supervised training with QA pairs Yes DenSPI Classic + Neural IR ‚Äì Yes T5 + SSM ‚Äì T5 SSM on CommonCrawl data + Fine-tuning on QA data Yes GPT3 ‚Äì GPT3 NSP on CommonCrawl data Yes RAG DPR retriever BART Yes Fusion-in-Decoder BM25 / DPR retriever Tranformer No Fig. 16. A comparison of performance of several QA models on common QA datasets. On TriviaQA, two columns of results are reported, on the open domain test set (left) and on the hidden test set (right). (Image source: Izacard \u0026 Grave, 2020). Citation Cited as:\nWeng, Lilian. (Oct 2020). How to build an open-domain question answering system? Lil‚ÄôLog. https://lilianweng.github.io/posts/2020-10-29-odqa/.\nOr\n@article{weng2020odqa, title = \"How to Build an Open-Domain Question Answering System?\", author = \"Weng, Lilian\", journal = \"lilianweng.github.io\", year = \"2020\", month = \"Oct\" url = \"https://lilianweng.github.io/posts/2020-10-29-odqa/\" } Appendix: QA Datasets SQuAD 2.0: the Stanford QA dataset. RACE: a reading comprehension dataset collected from English Examinations that are created for middle school and high school students. TREC QA: the TREC QA collections. MS MARCO: a QA dataset featuring 100,000 real Bing questions and a human generated answer. CuratedTREC: based on the benchmarks from the TREC QA tasks that have been curated by Baudis \u0026 Sedivy (2015). Google Natural Questions: contains real user questions issued to Google search, and answers found from Wikipedia by annotators. WebQuestions: designed for knowledge-base QA with answers restricted to Freebase entities. WikiQA: Bing query logs were used as the source of questions. Each question is then linked to a Wikipedia page that potentially contains the answer. WikiMovies: contains movie-related questions from the OMDb and MovieLens databases and where the questions can be answered using Wikipedia pages. WikiReading: to predict textual values from the structured knowledge base Wikidata by reading the text of the corresponding Wikipedia articles. TriviaQA: a reading comprehension dataset containing 95K question-answer pairs authored by trivia enthusiasts and independently gathered multiple evidence documents per question. Jeopardy! Questions: contains 200,000+ Jeopardy! questions. DeepMind Q\u0026A Dataset: question/answer pairs from CNN and Daily Mail articles. bAbi: a rich collection of datasets for text understanding by Facebook. FEVER: for fact extraction and verification. SearchQA: question-answer pairs were crawled from from J! Archive, and then augmented with text snippets from Google. Quasar-T: a collection of open-domain trivia questions and their answers obtained from various internet sources. Quiz bowl: contains data from a trivia competition called quiz bowl. AmbigNQ: ambiguous questions selected from NQ-OPEN dataset. QA-Overlap: a collections of overlapped answers/questions between train and test set for Natural Questions, TriviaQA, and WebQuestions. References [1] Danqi Chen \u0026 Scott Yih. ‚ÄúACL2020 Tutorial: Open-Domain Question Answering‚Äù July 2020.\n[2] Danqi Chen, et al. ‚ÄúReading Wikipedia to Answer Open-Domain Questions‚Äù ACL 2017. | code\n[3] Shuohang Wang, et al. ‚ÄúR^3: Reinforced Ranker-Reader for Open-Domain Question Answering‚Äù AAAI 2018.\n[4] Jimmy Lin. ‚ÄúThe neural hype and comparisons against weak baselines.‚Äù ACM SIGIR Forum. Vol. 52. No. 2. 2019.\n[5] Wei Yang, et al. ‚ÄúEnd-to-End Open-Domain Question Answering with BERTserini‚Äù NAACL 2019.\n[6] Christopher Clark \u0026 Matt Gardner. ‚ÄúSimple and Effective Multi-Paragraph Reading Comprehension.‚Äù arXiv:1710.10723 (2017).\n[7] Rodrigo Nogueira \u0026 Kyunghyun Cho. ‚ÄúPassage Re-ranking with BERT.‚Äù arXiv preprint arXiv:1901.04085 (2019). | code\n[8] Zhiguo Wang, et al. ‚ÄúMulti-passage BERT: A globally normalized BERT model for open-domain question answering.‚Äù EMNLP 2019.\n[9] Minjoon Seo et al. ‚ÄúReal-time open-domain question answering with dense-sparse phrase index.‚Äù ACL 2019.\n[10] Kenton Lee, et al. ‚ÄúLatent Retrieval for Weakly Supervised Open Domain Question Answering‚Äù ACL 2019.\n[11] Kelvin Guu, et al. ‚ÄúREALM: Retrieval-Augmented Language Model Pre-Training‚Äù arXiv:2002.08909 (2020).\n[12] Vladimir Karpukhin et al. ‚ÄúDense passage retrieval for open-domain question answering.‚Äù. EMNLP 2020. | code\n[13] Patrick Lewis et al. ‚ÄúRetrieval-Augmented Generation for Knowledge-Intensive NLP Tasks‚Äù arXiv:2005.11401 (2020).\n[14] Adam Roberts, et al. ‚ÄúHow Much Knowledge Can You Pack Into the Parameters of a Language Model?‚Äù EMNLP 2020.\n[15] Tom Brown, et al. ‚ÄúLanguage models are few-shot learners.‚Äù arXiv:2005.14165 (2020).\n[16] Fabio Petroni, et al. ‚ÄúHow Context Affects Language Models‚Äô Factual Predictions‚Äù AKBC 2020.\n[17] Gautier Izacard \u0026 Edouard Grave. ‚ÄúLeveraging passage retrieval with generative models for open domain question answering.‚Äù arXiv:2007.01282 (2020).\n[18] ‚ÄúDive into deep learning: Beam search‚Äù\n[19] Patrick Lewis, et al. ‚ÄúQuestion and Answer Test-Train Overlap in Open-Domain Question Answering Datasets‚Äù arXiv:2008.02637 (2020). | data\n[20] Herv√© Jegou, et al. ‚ÄúFaiss: A library for efficient similarity search‚Äù Mar 2017.\n[21] Vidhisha Balachandran, et al. ‚ÄúSimple and Efficient ways to Improve REALM.‚Äù arXiv:2104.08710 (2021).\n",
  "wordCount" : "6958",
  "inLanguage": "en",
  "datePublished": "2020-10-29T00:00:00Z",
  "dateModified": "2020-10-29T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lilian Weng"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lilianweng.github.io/posts/2020-10-29-odqa/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lil'Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lilianweng.github.io/favicon_peach.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lilianweng.github.io/" accesskey="h" title="Lil&#39;Log (Alt + H)">Lil&#39;Log</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lilianweng.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/faq" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="emojisearch.app">
                    <span>emojisearch.app</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      How to Build an Open-Domain Question Answering System?
    </h1>
    <div class="post-meta">Date: October 29, 2020  |  Estimated Reading Time: 33 min  |  Author: Lilian Weng

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-is-open-domain-question-answering" aria-label="What is Open-Domain Question Answering?">What is Open-Domain Question Answering?</a><ul>
                        
                <li>
                    <a href="#notation" aria-label="Notation">Notation</a></li>
                <li>
                    <a href="#concerns-of-qa-data-fine-tuning" aria-label="Concerns of QA data fine-tuning">Concerns of QA data fine-tuning</a></li></ul>
                </li>
                <li>
                    <a href="#open-book-qa-retriever-reader" aria-label="Open-book QA: Retriever-Reader">Open-book QA: Retriever-Reader</a><ul>
                        
                <li>
                    <a href="#retriever-model" aria-label="Retriever Model">Retriever Model</a><ul>
                        
                <li>
                    <a href="#classic-ir" aria-label="Classic IR">Classic IR</a></li>
                <li>
                    <a href="#neural-ir" aria-label="Neural IR">Neural IR</a></li></ul>
                </li>
                <li>
                    <a href="#reader-model" aria-label="Reader Model">Reader Model</a><ul>
                        
                <li>
                    <a href="#bi-directional-lstm" aria-label="Bi-directional LSTM">Bi-directional LSTM</a></li>
                <li>
                    <a href="#bert-universe" aria-label="BERT-universe">BERT-universe</a></li></ul>
                </li>
                <li>
                    <a href="#end-to-end-joint-training" aria-label="End-to-end Joint Training">End-to-end Joint Training</a></li></ul>
                </li>
                <li>
                    <a href="#open-book-qa-retriever-generator" aria-label="Open-book QA: Retriever-Generator">Open-book QA: Retriever-Generator</a></li>
                <li>
                    <a href="#closed-book-qa-generative-language-model" aria-label="Closed-book QA: Generative Language Model">Closed-book QA: Generative Language Model</a></li>
                <li>
                    <a href="#related-techniques" aria-label="Related Techniques">Related Techniques</a><ul>
                        
                <li>
                    <a href="#fast-maximum-inner-product-search-mips" aria-label="Fast Maximum Inner Product Search (MIPS)">Fast Maximum Inner Product Search (MIPS)</a></li>
                <li>
                    <a href="#language-model-pre-training" aria-label="Language Model Pre-training">Language Model Pre-training</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li>
                <li>
                    <a href="#citation" aria-label="Citation">Citation</a></li>
                <li>
                    <a href="#appendix-qa-datasets" aria-label="Appendix: QA Datasets">Appendix: QA Datasets</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><!-- A model that is capable of answering any question with regard to factual knowledge can enable many useful applications. This post delves into how we can build an Open-Domain Question Answering (ODQA) system, assuming we have access to a powerful pretrained language model. Both closed-book and open-book approachs are discussed. -->
<p><span class="update">[Updated on 2020-11-12: add <a href="#openai-api-example">an example</a> on closed-book factual QA using OpenAI API (beta).</span></p>
<p>A model that can answer any question with regard to factual knowledge can lead to many useful and practical applications, such as working as a chatbot or an AI assistantü§ñ. In this post, we will review several common approaches for building such an open-domain question answering system.</p>
<p>Disclaimers given so many papers in the wild:</p>
<ul>
<li>Assume we have access to a powerful pretrained <a href="https://lilianweng.github.io/posts/2019-01-31-lm/">language model</a>.</li>
<li>We do not cover how to use structured knowledge base (e.g. Freebase, WikiData) here.</li>
<li>We only focus on a single-turn QA instead of a multi-turn conversation style QA.</li>
<li>We mostly focus on QA models that contain neural networks, specially Transformer-based language models.</li>
<li>I admit that I missed a lot of papers with architectures designed specifically for QA tasks between 2017-2019üòî</li>
</ul>
<h1 id="what-is-open-domain-question-answering">What is Open-Domain Question Answering?<a hidden class="anchor" aria-hidden="true" href="#what-is-open-domain-question-answering">#</a></h1>
<p><strong>Open-domain Question Answering (ODQA)</strong> is a type of language tasks, asking a model to produce answers to factoid questions in natural language. The true answer is objective, so it is simple to evaluate model performance.</p>
<p>For example,</p>
<pre tabindex="0"><code>Question: What did Albert Einstein win the Nobel Prize for?
Answer: The law of the photoelectric effect.
</code></pre><p>The &ldquo;open-domain&rdquo; part refers to the lack of the relevant context for any arbitrarily asked factual question. In the above case, the model only takes as the input the question but no article about &ldquo;why Einstein didn&rsquo;t win a Nobel Prize for the theory of relativity&rdquo; is provided, where the term &ldquo;the law of the photoelectric effect&rdquo; is likely mentioned. In the case when both the question and the context are provided, the task is known as <strong>Reading comprehension (RC)</strong>.</p>
<p>An ODQA model may work with or without <em>access to an external source of knowledge</em> (e.g. Wikipedia) and these two conditions are referred to as <em>open-book</em> or <em>closed-book</em> question answering, respectively.</p>
<p>When considering different types of open-domain questions, I like the classification by <a href="https://arxiv.org/abs/2008.02637">Lewis, et al., 2020</a>, in increasing order of difficulty:</p>
<ol>
<li>A model is able to correctly memorize and respond with the answer to a question that has been seen at training time.</li>
<li>A model is able to answer novel questions at test time and choose an answer from the set of answers it has seen during training.</li>
<li>A model is able to answer novel questions which have answers not contained in the training dataset.</li>
</ol>
<img src="QA-summary.png" style="width: 100%;" class="center" />
<figcaption>Fig. 1. Overview of three frameworks discussed in this post.</figcaption>
<h2 id="notation">Notation<a hidden class="anchor" aria-hidden="true" href="#notation">#</a></h2>
<p>Given a question $x$ and a ground truth answer span $y$, the context passage containing the true answer is labelled as $z \in \mathcal{Z}$, where $\mathcal{Z}$ is an external knowledge corpus. Wikipedia is a common choice for such an external knowledge source.</p>
<h2 id="concerns-of-qa-data-fine-tuning">Concerns of QA data fine-tuning<a hidden class="anchor" aria-hidden="true" href="#concerns-of-qa-data-fine-tuning">#</a></h2>
<p>Before we dive into the details of many models below. I would like to point out one concern of fine-tuning a model with common QA datasets, which appears as one fine-tuning step in several ODQA models. It could be concerning, because there is a significant overlap between questions in the train and test sets in several public QA datasets.</p>
<p><a href="https://arxiv.org/abs/2008.02637">Lewis, et al., (2020)</a> (<a href="https://github.com/facebookresearch/QA-Overlap">code</a>) found that 58-71% of test-time answers are also present somewhere in the training sets and 28-34% of test-set questions have a near-duplicate paraphrase in their corresponding training sets. In their experiments, several models performed notably worse when duplicated or paraphrased questions were removed from the training set.</p>
<h1 id="open-book-qa-retriever-reader">Open-book QA: Retriever-Reader<a hidden class="anchor" aria-hidden="true" href="#open-book-qa-retriever-reader">#</a></h1>
<p>Given a factoid question, if a language model has no context or is not big enough to memorize the context which exists in the training dataset, it is unlikely to guess the correct answer. In an open-book exam, students are allowed to refer to external resources like notes and books while answering test questions. Similarly, a ODQA system can be paired with a rich knowledge base to identify relevant documents as evidence of answers.</p>
<p>We can decompose the process of finding answers to given questions into two stages,</p>
<ol>
<li>Find the related context in an external repository of knowledge;</li>
<li>Process the retrieved context to <em>extract</em> an answer.</li>
</ol>
<img src="QA-retriever-reader.png" style="width: 100%;" class="center" />
<figcaption>Fig. 2. The retriever-reader QA framework combines information retrieval with machine reading comprehension.</figcaption>
<p>Such a retriever + reader framework was first proposed in <strong>DrQA</strong> (&ldquo;Document retriever Question-Answering&rdquo; by <a href="https://arxiv.org/abs/1704.00051">Chen et al., 2017</a>; <a href="https://github.com/facebookresearch/DrQA">code</a>). The retriever and the reader components can be set up and trained independently, or jointly trained <a href="#end-to-end-joint-training">end-to-end</a>.</p>
<h2 id="retriever-model">Retriever Model<a hidden class="anchor" aria-hidden="true" href="#retriever-model">#</a></h2>
<p>Two popular approaches for implementing the retriever is to use the information retrieval (IR) system that depends on (1) the classic non-learning-based <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">TF-IDF</a> features (&ldquo;classic IR&rdquo;) or (2) dense embedding vectors of text produced by neural networks (&ldquo;neural IR&rdquo;).</p>
<h3 id="classic-ir">Classic IR<a hidden class="anchor" aria-hidden="true" href="#classic-ir">#</a></h3>
<p><strong>DrQA</strong> (<a href="https://arxiv.org/abs/1704.00051">Chen et al., 2017</a>) adopts an efficient non-learning-based search engine based on the <a href="https://en.wikipedia.org/wiki/Vector_space_model">vector space model</a>. Every query and document is modelled as a bag-of-word vector, where each term is weighted by TF-IDF (term frequency $\times$ inverse document frequency).</p>
<div>
$$
\begin{aligned}
\text{tf-idf}(t, d, \mathcal{D}) &= \text{tf}(t, d) \times \text{idf}(t, \mathcal{D}) \\
\text{tf}(t, d) &= \log(1 + \text{freq}(t, d)) \\
\text{idf}(t, \mathcal{D}) &= \log \Big( \frac{\vert\mathcal{D}\vert}{\vert d\in\mathcal{D}: t\in d\vert} \Big)
\end{aligned}
$$
</div>
<p>where $t$ is a unigram or bigram term in a document $d$ from a collection of documents $\mathcal{D}$ . $\text{freq}(t, d)$ measures how many times a term $t$ appears in $d$. Note that the term-frequency here includes bigram counts too, which is found to be very helpful because the local word order is taken into consideration via bigrams. As part of the implementation, DrQA maps the bigrams of $2^{24}$ bins using unsigned murmur3 hash.</p>
<p>Precisely, DrQA implemented Wikipedia as its knowledge source and this choice has became a default setting for many ODQA studies since then. The non-ML document retriever returns the top $k=5$ most relevant Wikipedia articles given a question.</p>
<p><strong>BERTserini</strong> (<a href="https://arxiv.org/abs/1902.01718">Yang et al., 2019</a>) pairs the open-source <a href="https://github.com/castorini/anserini"><em>Anserini</em></a> IR toolkit as the retriever with a fine-tuned pre-trained BERT model as the reader. The top $k$ documents ($k=10$) are retrieved via the <code>post-v3.0</code> branch of Anserini with the query treated as a bag of words. The retrieved text segments are ranked by <a href="https://en.wikipedia.org/wiki/Okapi_BM25">BM25</a>, a classic TF-IDF-based retrieval scoring function. In terms of the effect of text granularity on performance, they found that paragraph retrieval &gt; sentence retrieval &gt; article retrieval.</p>
<img src="BERTserini-arch.png" style="width: 100%;" class="center" />
<figcaption>Fig. 3. An illustration of BERTserini architecture. (Image source: <a href="https://arxiv.org/abs/1902.01718" target="_blank">Yang et al., 2019</a>)</figcaption>
<p><em>ElasticSearch + BM25</em> is used by the <strong>Multi-passage BERT</strong> QA model (<a href="https://arxiv.org/abs/1908.08167">Wang et al., 2019</a>). They found that splitting articles into passages with the length of 100 words by <em>sliding window</em> brings 4% improvements, since splitting documents into passages without overlap may cause some near-boundary evidence to lose useful contexts.</p>
<h3 id="neural-ir">Neural IR<a hidden class="anchor" aria-hidden="true" href="#neural-ir">#</a></h3>
<p>There is a long history in learning a low-dimensional representation of text, denser than raw term-based vectors (<a href="http://lsa.colorado.edu/papers/JASIS.lsi.90.pdf">Deerwester et al., 1990</a>; <a href="https://www.aclweb.org/anthology/W11-0329/">Yih, et al., 2011</a>). Dense representations can be learned through matrix decomposition or some neural network architectures (e.g. MLP, LSTM, bidirectional LSTM, etc). When involving neural networks, such approaches are referred to as &ldquo;Neural IR&rdquo;, Neural IR is a new category of methods for retrieval problems, but it is not necessary to perform better/superior than classic IR (<a href="https://sigir.org/wp-content/uploads/2019/01/p040.pdf">Lim, 2018</a>).</p>
<p>After the success of many large-scale <a href="https://lilianweng.github.io/posts/2019-01-31-lm/">general language models</a>, many QA models embrace the following approach:</p>
<div>
$$
h_x = E_x(x)\quad
h_z = E_z(z)\quad
\text{score}(x, z) = h_x^\top h_z
$$
</div>
<ol>
<li>Extract the dense representations of a question $x$ and a context passage $z$ by feeding them into a language model;</li>
<li>Use the dot-product of these two representations as the retrieval score to rank and select most relevant passages.</li>
</ol>
<p>ORQA, REALM and DPR all use such a scoring function for context retrieval, which will be described in detail in a <a href="#end-to-end-joint-training">later section</a> on the end-to-end QA model.</p>
<p>An extreme approach, investigated by <strong>DenSPI</strong> (&ldquo;Dense-Sparse Phrase Index&rdquo;; <a href="https://arxiv.org/abs/1906.05807">Seo et al., 2019</a>), is to encode all the text in the knowledge corpus at the <em>phrase</em> level and then only rely on the retriever to identify the most relevant phrase as the predicted answer. In this way, the retriever+reader pipeline is reduced to only retriever. Of course, the index would be much larger and the retrieval problem is more challenging.</p>
<p>DenSPI introduces a <em>query-agnostic</em> indexable representation of document phrases. Precisely it encodes query-agnostic representations of text spans in Wikipedia offline and looks for the answer at inference time by performing nearest neighbor search. It can drastically speed up the inference time, because there is no need to re-encode documents for every new query, which is often required by a reader model.</p>
<p>Given a question $x$ and a fixed set of (Wikipedia) documents, $z_1, \dots, z_K$ and each document $z_k$ contains $N_k$ words, $z_k = \langle z_k^{(1)}, \dots, z_k^{(N_k)}\rangle$. An ODQA model is a scoring function $F$ for each candidate phrase span $z_k^{(i:j)}, 1 \leq i \leq j \leq N_k$, such that the truth answer is the phrase with maximum score: $y = {\arg\max}_{k,i,j} F(x, z_k^{(i:j)})$.</p>
<p>The phrase representation $z_k^{(i:j)}$ combines both dense and sparse vectors, $z_k^{(i:j)} = [d_k^{(i:j)}, s_k^{(i:j)}] \in \mathbb{R}^{d^d + d^s}$ (note that $d^d \ll d^s$):</p>
<ul>
<li>The dense vector $d_k^{(i:j)}$ is effective for encoding local <em>syntactic</em> and <em>semantic</em> cues, as what can be learned by a pretrained language model.</li>
<li>The sparse vector $s_k^{(i:j)}$ is superior at encoding precise <em>lexical</em> information. The sparse vector is term-frequency-based encoding. DenSPI uses 2-gram term-frequency same as DrQA, resulting a highly sparse representation ($d^s \approx 16$M)</li>
</ul>
<p>The dense vector $d^{(i:j)}$ is further decomposed into three parts, $d^{(i:j)} = [a_i, b_j, c_{ij}] \in \mathbb{R}^{2d^b + 1}$ where $2d^b + 1 = d^d$. All three components are learned based on different columns of the fine-tuned BERT representations.</p>
<ul>
<li>A vector $a_i$ encodes the <em>start</em> position for the $i$-th word of the document;</li>
<li>A vector $b_j$ encodes the <em>end</em> position for the $j$-th word of the document;</li>
<li>A scalar $c_{ij}$ measures the <em>coherency</em> between the start and the end vectors, helping avoid non-constituent phrases during inference.</li>
</ul>
<p>For all possible $(i,j,k)$ tuples where $j-i &lt; J$, the text span embeddings are precomputed and stored as a <em>phrase index</em>. The maximum span length $J$ is a predefined scalar constant.</p>
<img src="DenSPI-arch.png" style="width: 75%;" class="center" />
<figcaption>Fig. 4. An illustration of Dense-Sparse Phrase Index (DenSPI) architecture. (Image source: <a href="https://arxiv.org/abs/1906.05807" target="_blank">Seo et al., 2019</a>)</figcaption>
<p>At the inference time, the question is mapped into the same vector space $x=[d&rsquo;, s&rsquo;] \in \mathbb{R}^{d^d + d^s}$, where the dense vector $d&rsquo;$ is extracted from the BERT embedding of the special <code>[CLS]</code> symbol. The same BERT model is shared for encoding both questions and phrases. The final answer is predicted by $k^*, i^*, j^* = \arg\max x^\top z_k^{(i:j)}$.</p>
<h2 id="reader-model">Reader Model<a hidden class="anchor" aria-hidden="true" href="#reader-model">#</a></h2>
<p>The reader model learns to solve the reading comprehension task &mdash; extract an answer for a given question from a given context document. Here we only discuss approaches for machine comprehension using neural networks.</p>
<h3 id="bi-directional-lstm">Bi-directional LSTM<a hidden class="anchor" aria-hidden="true" href="#bi-directional-lstm">#</a></h3>
<p>The reader model for answer detection of <strong>DrQA</strong> (<a href="https://arxiv.org/abs/1704.00051">Chen et al., 2017</a>) is a 3-layer bidirectional LSTM with hidden size 128. Every relevant paragraph of retrieved Wikipedia articles is encoded by a sequence of feature vector, $\{\tilde{\mathbf{z}}_1, \dots, \tilde{\mathbf{z}}_m \}$. Each feature vector $\hat{\mathbf{z}}_i \in \mathbb{R}^{d_z}$ is expected to capture useful contextual information around one token $z_i$. The feature consists of several categories of features:</p>
<ol>
<li>Word embeddings: A 300d <a href="https://lilianweng.github.io/posts/2017-10-15-word-embedding/#glove-global-vectors">Glove</a> word embedding trained from 800B Web crawl data, $f_\text{embed} = E_g(z_i)$.</li>
<li>Exact match: Whether a word $z_i$ appears in the question $x$, $f_\text{match} = \mathbb{I}(z_i \in x)$.</li>
<li>Token features: This includes POS (part-of-speech) tagging, NER (named entity recognition), and TF (term-frequency), $f_\text{token}(z_i) = (\text{POS}(z_i), \text{NER}(z_i), \text{TF}(z_i))$.</li>
<li>Aligned question embedding: The attention score $y_{ij}$ is designed to capture inter-sentence matching and similarity between the paragraph token $z_i$ and the question word $x_j$. This feature adds soft alignments between similar but non-identical words.</li>
</ol>
<div>
$$
\begin{aligned}
f_\text{align}(z_i) &= \sum_j y_{i,j} E_g(x_j) \\ 
y_{i,j} &= \frac{\exp(\alpha(E_g(z_i))^\top \alpha(E_g(x_j)) )}{\sum_{j'} \exp(\alpha(E_g(z_i))^\top \alpha(E_g(x_{j'})) ) }
\end{aligned}
$$
</div>
<p>where $\alpha$ is a single dense layer with ReLU and $E_g(.)$ is the glove word embedding.</p>
<p>The feature vector of a paragraph of $m$ tokens is fed into LSTM to obtain the final paragraph vectors:</p>
<div>
$$
\begin{aligned}
\mathbf{z} = \{\mathbf{z}_1, \dots, \mathbf{z}_m\} &= \text{LSTM}(\{\tilde{\mathbf{z}}_1, \dots, \tilde{\mathbf{z}}_m\}) \\
\text{where } \tilde{\mathbf{z}}_i &= \{f_\text{embed}, f_\text{match}, f_\text{token}, f_\text{align}\}
\end{aligned}
$$
</div>
<p>The question is encoded as a weighted sum of the embeddings of every word in the question:</p>
<div>
$$
\mathbf{x} = \sum_j b_j E(x_j) \quad b_j = \text{softmax}(\mathbf{w}^\top E(x_j))
$$
</div>
<p>where $\mathbf{w}$ is a weight vector to learn.</p>
<p>Once the feature vectors are constructed for the question and all the related paragraphs, the reader needs to predict the probabilities of each position in a paragraph to be the start and the end of an answer span, $p_\text{start}(i_s)$ and $p_\text{end}(i_s)$, respectively. Across all the paragraphs, the optimal span is returned as the final answer with maximum $p_\text{start}(i_s)  \times p_\text{end}(i_e) $.</p>
<div>
$$
\begin{aligned}
p_\text{start}(i_s) \propto \exp(\mathbf{z}_{i_s} \mathbf{W}_s \mathbf{x}) \\ 
p_\text{end}(i_e) \propto \exp(\mathbf{z}_{i_e} \mathbf{W}_e \mathbf{x}) \\
\text{ s.t. } i_s \leq i_e \leq i_s + 15
\end{aligned}
$$
</div>
<p>where $\mathbf{W}_s$ and $\mathbf{W}_e$ are learned parameters.</p>
<h3 id="bert-universe">BERT-universe<a hidden class="anchor" aria-hidden="true" href="#bert-universe">#</a></h3>
<p>Following the success of <a href="https://lilianweng.github.io/posts/2019-01-31-lm/#bert">BERT</a> (<a href="https://arxiv.org/abs/1810.04805">Devlin et al., 2018</a>), many QA models develop the machine comprehension component based on BERT. Let&rsquo;s define the BERT model as a function that can take one or multiple strings (concatenated by <code>[SEP]</code>) as input and outputs a set of BERT encoding vectors for the special <code>[CLS]</code> token and every input token:</p>
<div>
$$
\text{BERT}(s_1, s_2, \dots) = [\mathbf{h}^\texttt{[CLS]}, \mathbf{h}^{(1)}, \mathbf{h}^{(2)}, \dots]
$$
</div>
<p>where $\mathbf{h}^\texttt{[CLS]}$ is the embedding vector for the special <code>[CLS]</code> token and $\mathbf{h}^{(i)}$ is the embedding vector for the $i$-th token.</p>
<p>To use BERT for reading comprehension, it learns two additional weights, $\mathbf{W}_s$ and $\mathbf{W}_e$, and $\text{softmax}(\mathbf{h}^{(i)}\mathbf{W}_s)$ and $\text{softmax}(\mathbf{h}^{(i)}\mathbf{W}_e)$ define two probability distributions of start and end position of the predicted span per token.</p>
<p><strong>BERTserini</strong> (<a href="https://arxiv.org/abs/1902.01718">Yang et al., 2019</a>) utilizes a pre-trained BERT model to work as the reader. Their experiments showed that <em>fine-tuning</em> pretrained BERT with SQuAD is sufficient to achieve high accuracy in identifying answer spans.</p>
<img src="BERT-RC.png" style="width: 60%;" class="center" />
<figcaption>Fig. 5. How BERT is used to solve question-answering tasks. (Image source: <a href="https://arxiv.org/abs/1810.04805" target="_blank">Devlin et al., 2018</a>)</figcaption>
<p>The key difference of the BERTserini reader from the original BERT is: to allow comparison and aggregation of results from different segments, the final softmax layer over different answer spans is removed. The pre-trained BERT model is fine-tuned on the training set of SQuAD, where all inputs to the reader are padded to 384 tokens with the learning rate 3e-5.</p>
<p>When ranking all the extracted answer spans, the retriever score (BM25) and the reader score (probability of token being the start position $\times$ probability of the same token being the end position ) are combined via linear interpolation.</p>
<p>The original BERT normalizes the probability distributions of start and end position per token for every passage independently. Differently, the <strong>Multi-passage BERT</strong> (<a href="https://arxiv.org/abs/1908.08167">Wang et al., 2019</a>) normalizes answer scores across all the retrieved passages of one question <a href="https://arxiv.org/abs/1710.10723">globally</a>. Precisely, multi-passage BERT removes the final normalization layer per passage in BERT for QA (same as in BERTserini) and then adds a global <code>softmax</code> over all the word positions of all the passages. Global normalization makes the reader model more stable while pin-pointing answers from a large number of passages.</p>
<p>In addition, multi-passage BERT implemented an independent <em>passage ranker</em> model via another BERT model and the rank score for $(x, z)$ is generated by a <code>softmax</code> over the representation vectors of the first <code>[CLS]</code> token. The passage ranker brings in extra 2% improvements. Similar idea of re-ranking passages with BERT was discussed in <a href="https://arxiv.org/abs/1901.04085">Nogueira &amp; Cho, 2019</a>, too.</p>
<p>Interestingly, <a href="https://arxiv.org/abs/1908.08167">Wang et al., 2019</a> found that <em>explicit inter-sentence matching</em> does not seem to be critical for RC tasks with BERT; check the original paper for how the experiments were designed. One possible reason is that the multi-head self-attention layers in BERT has already embedded the inter-sentence matching.</p>
<h2 id="end-to-end-joint-training">End-to-end Joint Training<a hidden class="anchor" aria-hidden="true" href="#end-to-end-joint-training">#</a></h2>
<p>The retriever and reader components can be jointly trained. This section covers R^3, ORQA, REALM and DPR. There are a lot of common designs, such as BERT-based dense vectors for retrieval and the loss function on maximizing the marginal likelihood of obtaining true answers.</p>
<p>The retriever and reader models in the <strong>R^3</strong> (&ldquo;Reinforced Ranker-Reader&rdquo;; <a href="https://arxiv.org/abs/1709.00023">Wang, et al., 2017</a>) QA system are jointly trained via <a href="https://lilianweng.github.io/posts/2018-02-19-rl-overview/">reinforcement learning</a>. (Note that to keep the term consistent between papers in this section, the &ldquo;ranker&rdquo; model in the original R^3 paper is referred to as the &ldquo;retriever&rdquo; model here.) Both components are variants of <a href="https://arxiv.org/abs/1512.08849">Match-LSTM</a>, which relies on an attention mechanism to compute word similarities between the passage and question sequences.</p>
<p><strong>How does the Match-LSTM module work?</strong> Given a question $\mathbf{X}$ of $d_x$ words and a passage $\mathbf{Z}$ of $d_z$ words, both representations use fixed <a href="https://lilianweng.github.io/posts/2017-10-15-word-embedding/#glove-global-vectors">Glove</a> word embeddings,</p>
<div>
$$
\begin{aligned}
\mathbf{H}^x &= \text{BiLSTM}(\mathbf{X}) \in \mathbb{R}^{l \times d_x} \\
\mathbf{H}^z &= \text{BiLSTM}(\mathbf{Z}) \in \mathbb{R}^{l \times d_z} \\
\mathbf{G} &= \text{softmax}((\mathbf{W}^g \mathbf{H}^x + \mathbf{b}^g \otimes \mathbf{e}_{d_x})^\top \mathbf{H}^z) \in \mathbb{R}^{d_x \times d_z} & \text{; an attention matrix}\\
\bar{\mathbf{H}}^x &= \mathbf{H}^x \mathbf{G} \in \mathbb{R}^{l \times d_z} \\
\mathbf{M} &= \text{ReLU} \Big( \mathbf{W}^m \begin{bmatrix}
\mathbf{H}^z \\
\bar{\mathbf{H}}^x \\
\mathbf{H}^z \odot \bar{\mathbf{H}}^x \\
\mathbf{H}^z - \bar{\mathbf{H}}^x
\end{bmatrix} \Big) \in \mathbb{R}^{2l \times d_z} \\
\mathbf{H}^m &= \text{BiLSTM}(M) \in \mathbb{R}^{l \times d_z}
\end{aligned}
$$
</div>
<p>where $l$ is the hidden dimension of the bidirectional LSTM module. $\mathbf{W}^g \in \mathbb{R}^{l\times l}$, $\mathbf{b}^g \in \mathbb{R}^l$, and $\mathbf{W}^m \in \mathbb{R}^{2l \times 4l}$ are parameters to learn. The operator $\otimes \mathbf{e}_{d_x}$ is the outer product to repeat the column vector $\mathbf{b}^g$ $d_x$ times.</p>
<p>The ranker and reader components share the same Match-LSTM module with two separate prediction heads in the last layer, resulting in $\mathbf{H}^\text{rank}$ and $\mathbf{H}^\text{reader}$.</p>
<img src="R^3-arch.png" style="width: 100%;" class="center" />
<figcaption>Fig. 6. The overview of R^3 (reinforced ranker-reader) architecture. Both components share the same Match-LSTM module. (Image source: <a href="https://arxiv.org/abs/1709.00023" target="_blank">Wang, et al., 2017</a>)</figcaption>
<p>The retriever runs a max-pooling operation per passage and then aggregates to output a probability of each passage entailing the answer.</p>
<div>
$$
\begin{aligned}
\mathbf{u}_i &= \text{max-pooling}(\mathbf{H}^\text{rank}_i) \in \mathbb{R}^l \\
\mathbf{C} &= \text{tanh}(\mathbf{W}^c[\mathbf{u}_1;\dots;\mathbf{u}_N] + \mathbf{b}^c \otimes \mathbf{e}_N) \in \mathbb{R}^{l \times n} \\
\gamma &= \text{softmax}(\mathbf{w}^c \mathbf{C}) \in \mathbb{R}^n
\end{aligned}
$$
</div>
<p>Finally, the retriever is viewed as a <em>policy</em> to output action to sample a passage according to predicted $\gamma$,</p>
<div>
$$
\pi(z \vert x; \theta^\gamma) = \gamma_z
$$
</div>
<p>The reader predicts the start position $\beta^s$ and the end position $\beta^e$ of the answer span. Two positions are computed in the same way, with independent parameters to learn. There are $V$ words in all the passages involved.</p>
<div>
$$
\begin{aligned}
\mathbf{H}^\text{read} &= [\mathbf{H}^\text{read}_\tau; \mathbf{H}^\text{read}_{\text{neg}_1}; \dots; \mathbf{H}^\text{read}_{\text{neg}_n}] \\
\mathbf{F}^s &= \text{tanh}(\mathbf{W}^s \mathbf{H}^\text{read} + \mathbf{b}^s \otimes \mathbf{e}_V) \quad
\beta^s = \text{softmax}(\mathbf{w}^s \mathbf{F}^s) \in \mathbb{R}^V \\
\mathbf{F}^e &= \text{tanh}(\mathbf{W}^e \mathbf{H}^\text{read} + \mathbf{b}^e \otimes \mathbf{e}_V) \quad
\beta^e = \text{softmax}(\mathbf{w}^e \mathbf{F}^e) \in \mathbb{R}^V \\
L(y \vert z, x) &= -\log(\beta^s_{y_z^s})-\log(\beta^e_{y_z^e})
\end{aligned}
$$
</div>
<p>where $y$ is the ground-truth answer and the passage $z$ is sampled by the retriever. $\beta^s_{y_z^s}$ and $\beta^s_{y_z^e}$ represent the probabilities of the start and end positions of $y$ in passage $z$.</p>
<p>The training objective for the end-to-end R^3 QA system is to minimize the negative log-likelihood of obtaining the correct answer $y$ given a question $x$,</p>
<div>
$$
\begin{aligned}
\mathcal{J}(\theta) &= -\mathbb{E}_{z\sim\pi(.\vert x)} [L(y \vert z, x)] \\
\nabla \mathcal{J}(\theta) 
&= - \nabla_\theta \sum_z \pi(z \vert x) L(y \vert z, x) \\
&= - \sum_z \big( L(y \vert z, x) \nabla_\theta\pi(z \vert x) + \pi(z \vert x) \nabla_\theta L(y \vert z, x) \big) \\
&= - \mathbb{E}_{z\sim\pi(.\vert x)} \big( \color{red}{L(y \vert z, x)\nabla_\theta\log\pi(z \vert x)} + \nabla_\theta L(y \vert z, x) \big) \\
&\approx - \mathbb{E}_{z\sim\pi(.\vert x)} \big( \underbrace{\color{red}{R(y \vert z, x)\nabla_\theta\log\pi(z \vert x)}}_\text{REINFORCE} + \nabla_\theta L(y \vert z, x) \big)
\end{aligned}
$$
</div>
<p>Essentially in training, given a passage $z$ sampled by the retriever, the reader is trained by gradient descent while the retriever is trained by <a href="https://lilianweng.github.io/posts/2018-04-08-policy-gradient/#reinforce">REINFORCE</a> using $L(y \vert z, x)$ as the reward function. However, $L(y \vert z, x)$ is not bounded and may introduce a lot of variance. The paper replaces the reward with a customized scoring function by comparing the ground truth $y$ and the answer extracted by the reader $\hat{y}$:</p>
<div>
$$
R(y, \hat{y} \vert z) = \begin{cases}
2 & \text{if } y = \hat{y}\\
f1(y, \hat{y}) & \text{if } y \cap \hat{y} = \varnothing \\
-1 & \text{otherwise}
\end{cases}
$$
</div>
<img src="R^3-reward-flow.png" style="width: 30%;" class="center" />
<figcaption>Fig. 7. The workflow of R^3 training process. (Image source: <a href="https://github.com/danqi/acl2020-openqa-tutorial/blob/master/slides/part4-retriever-reader.pdf" target="_blank">acl2020-openqa-tutorial/slides/part4</a>)</figcaption>
<p><a id="ORQA" ></a><strong>ORQA</strong> (&ldquo;Open-Retrieval Question-Answering&rdquo;; <a href="https://arxiv.org/abs/1906.00300">Lee et al., 2019</a>) jointly learns a retriever + reader QA model to optimize marginal log-likelihood of obtaining correct answers in a supervised manner. No explicit &ldquo;black-box&rdquo; IR system is involved. Instead, it is capable of retrieving any text in an open corpus. During training, ORQA does not need ground-truth context passages (i.e. reading comprehension datasets) but only needs (question, answer) string pairs. Both retriever and reader components are based on BERT, but not shared.</p>
<img src="ORQA-retriever.png" style="width: 80%;" class="center" />
<figcaption>Fig. 8. An illustration of the retriever component in ORQA. (Image source: replotted based on one slide in <a href="https://github.com/danqi/acl2020-openqa-tutorial/blob/master/slides/part5-dense-retriever-e2e-training.pdf" target="_blank">acl2020-openqa-tutorial/slides/part5</a>)</figcaption>
<p>All the evidence blocks are ranked by a retrieval score, defined as the inner product of BERT embedding vectors of the <code>[CLS]</code> token of the question $x$ and the evidence block $z$. Note that the encoders for questions and context are independent.</p>
<div>
$$
\begin{aligned}
h_x &= \mathbf{W}_x \text{BERT}_x(x)^{\mathtt{[CLS]}} \\
h_z &= \mathbf{W}_z \text{BERT}_z(z)^{\mathtt{[CLS]}} \\
S_\text{retr}(z, x) &= h_x^\top h_z
\end{aligned}
$$
</div>
<p><a id="ICT-loss" ></a>The retriever module is pretrained with <em>Inverse Cloze Task (ICT)</em>, which is to predict the context given a sentence, opposite to the standard <a href="https://en.wikipedia.org/wiki/Cloze_test">Cloze Task</a>. The ICT objective is to maximize the retrieval score of the correct context $z$ given a random sentence $x$:</p>
<div>
$$
L_\text{ICT} = p_\text{early}(z \vert x) = \frac{\exp(S_\text{retr}(z, x))}{\sum_{z'\in\text{BATCH}(\mathcal{Z})} \exp(S_\text{retr}(z', x))}
$$
</div>
<p>where $\text{BATCH}(\mathcal{Z})$ is the set of evidence blocks in the same batch used as sampled negatives.</p>
<p>After such pretraining, the BERT retriever is expected to have representations good enough for evidence retrieval. Only the question encoder needs to be fine-tuned for answer extraction. In other words, the evidence block encoder (i.e., $\mathbf{W}_z$ and $\text{BERT}_z$) is fixed and thus all the evidence block encodings can be pre-computed with support for <a href="#fast-maximum-inner-product-search-mips">fast Maximum Inner Product Search (MIPS)</a>.</p>
<img src="ORQA-reader.png" style="width: 65%;" class="center" />
<figcaption>Fig. 9. An illustration of the reader component in ORQA. (Image source: <a href="https://github.com/danqi/acl2020-openqa-tutorial/blob/master/slides/part5-dense-retriever-e2e-training.pdf" target="_blank">acl2020-openqa-tutorial/slides/part5</a>)</figcaption>
<p>The reader follows the same design as in the original <a href="https://lilianweng.github.io/posts/2019-01-31-lm/#use-bert-in-downstream-tasks">BERT RC</a> experiments. It learns in a supervised manner, while the parameters of the evidence block encoder are fixed and all other parameters are fine-tuned. Given a question $x$ and a gold answer string $y$, the reader loss contains two parts:</p>
<div>
$$
\mathcal{L}(x, y) = \mathcal{L}_\text{early}(x, y) + \mathcal{L}_\text{full}(x, y)
$$
</div>
<p>(1) Find all correct text spans within top $k$ evidence blocks and optimize for the marginal likelihood of a text span $s$ that matches the true answer $y$:</p>
<div>
$$
\begin{aligned}
h_s &= \text{BERT}_R(x, y)^{(\text{START}(s))} \\
h_e &= \text{BERT}_R(x, y)^{(\text{END}(s))} \\
S_\text{read}(z, s, x) &= \text{MLP}([h_s; h_e]) \\
p(z, s \vert x) &= \frac{\exp(S_\text{read}(z, s, x))}{\sum_{z'\in\text{TOP}(k)} \sum_{s'\in z'} \exp(S_\text{read}(z', s', x))} \\
L_\text{full}(x, y) &= - \log \sum_{\substack{z \in \text{TOP}(k)\\ s \in z}} \sum_{y=\text{TEXT}(s)} p(z, s \vert x)
\end{aligned}
$$
</div>
<p>where $y=\text{TEXT}(s)$ indicates whether the answer $y$ matches the text span $s$. $\text{TOP}(k)$ is the top $k$ retrieved blocks according to $S_\text{retr}(z, x)$. The paper sets $k=5$.</p>
<p>(2) At the early stage of learning, when the retriever is not strong enough, it is possible none of the top $k$ blocks contains the answer. To avoid such sparse learning signals, ORQA considers a larger set of $c$ evidence blocks for more aggressive learning. The paper has $c=5000$.</p>
<div>
$$
L_\text{early}(x, y)
= -\log \sum_{\substack{z\in \text{TOP}(c)\\y\in\text{TEXT}(z)}} p_\text{early}(z\vert x)
= -\log \sum_{\substack{z\in \text{TOP}(c)\\y\in\text{TEXT}(z)}} \frac{\exp(S_\text{retr}(z, x)}{\sum_{z'\in\text{TOP}(c)} \exp(S_\text{retr}(z', x)}
$$
</div>
<p>Some issues in SQuAD dataset were discussed in the ORQA paper:</p>
<blockquote>
<p>&quot; The notable drop between development and test accuracy for SQuAD is a reflection of an artifact in the dataset&mdash;its 100k questions are derived from only 536 documents. Therefore, good retrieval targets are highly correlated between training examples, violating the IID assumption, and making it unsuitable for learned retrieval. We strongly suggest that those who are interested in end-to-end open-domain QA models no longer train and evaluate with SQuAD for this reason.&quot;</p>
</blockquote>
<p><a id="REALM" ></a><strong>REALM</strong> (&ldquo;Retrieval-Augmented Language Model pre-training&rdquo;; <a href="https://arxiv.org/abs/2002.08909">Guu et al., 2020</a>) also jointly trains retriever + reader by optimizing the marginal likelihood of obtaining the true answer:</p>
<div>
$$
p(y \vert x) 
= \sum_{z \in \mathcal{Z}} \underbrace{p(y \vert x, z)}_\text{reader} \underbrace{p(z \vert x)}_\text{retriever}
\approx \sum_{z \in \text{TOP}_k(\mathcal{Z})} p(y \vert x, z) p(z \vert x)
$$
</div>
<img src="REALM-train.png" style="width: 100%;" class="center" />
<figcaption>Fig. 10. REALM is first unsupervised pre-trained with salient spans masking and then fine-tuned with QA data. (Image source: <a href="https://arxiv.org/abs/2002.08909" target="_blank">Guu et al., 2020</a>).</figcaption>
<p>REALM computes two probabilities, $p(z \vert x)$ and $p(y \vert x, z)$, same as ORQA. However, different from ICT in ORQA, REALM upgrades the unsupervised pre-training step with several new design decisions, leading towards better retrievals. REALM pre-trains the model with Wikipedia or CC-News corpus.</p>
<ol>
<li><a id="ssm" ></a>Use <em>salient span masking</em>. Named entities and dates are identified. Then one of these &ldquo;salient spans&rdquo; is selected and masked. Salient span masking is a special case of MLM and works out well for QA tasks.</li>
<li>Add an <em>empty null document</em>. Because not every question demands a context document.</li>
<li>No trivial retrieval. The context document should not be same as the selected sentence with a masked span.</li>
<li>Apply the same ICT loss as in ORQA to encourage learning when the retrieval quality is still poor at the early stage of training.</li>
</ol>
<blockquote>
<p>&ldquo;Among all systems, the most direct comparison with REALM is ORQA (Lee et al., 2019), where the fine-tuning setup, hyperparameters and training data are identical. The improvement of REALM over ORQA is purely due to better pre-training methods.&rdquo; &mdash; from REALM paper.</p>
</blockquote>
<p>Both unsupervised pre-training and supervised fine-tuning optimize the same log-likelihood $\log p(y \vert x)$. Because the parameters of the retriever encoder for evidence documents are also updated in the process, the index for MIPS is changing. REALM asynchronously refreshes the index with the updated encoder parameters every several hundred training steps.</p>
<p><a href="https://arxiv.org/abs/2104.08710">Balachandran, et al. (2021)</a> found that REALM is significantly undertrained and REALM++ achieves great EM accuracy improvement (3-5%) by scaling up the model training with larger batch size and more retrieved documents for the reader to process.</p>
<p><a id="DPR" ></a><strong>DPR</strong> (&ldquo;Dense Passage Retriever&rdquo;; <a href="https://arxiv.org/abs/2004.04906">Karpukhin et al., 2020</a>, <a href="https://github.com/facebookresearch/DPR">code</a>) argues that ICT pre-training could be too computationally expensive and the ORQA&rsquo;s context encoder might be sub-optimal because it is not fine-tuned with question-answer pairs. DPR aims to resolve these two issues by only training a dense dual-encoder architecture for retrieval only from a small number of Q/A pairs, without any pre-training.</p>
<p>Same as previous work, DPR uses the dot-product (L2 distance or cosine similarity also works) of BERT representations as retrieval score. The loss function for training the dual-encoder is the NLL of the positive passage, which essentially takes the same formulation as <a href="#ICT-loss">ICT loss</a> of ORQA. Note that both of them consider other passages in the same batch as the negative samples, named <em>in-batch negative sampling</em>. The main difference is that DPR relies on supervised QA data, while ORQA trains with ICT on unsupervised corpus. At the inference time, DPR uses <a href="https://github.com/facebookresearch/faiss">FAISS</a> to run fast MIPS.</p>
<p>DPR did a set of comparison experiments involving several different types of negatives:</p>
<ol>
<li>Random: any random passage from the corpus;</li>
<li>BM25: top passages returned by BM25 which don&rsquo;t contain the answer but match most question tokens;</li>
<li>In-batch negative sampling (&ldquo;gold&rdquo;): positive passages paired with other questions which appear in the training set.</li>
</ol>
<p>DPR found that using gold passages from the same mini-batch and one negative passage with high BM25 score works the best. To further improve the retrieval results, DPR also explored a setting where a BM25 score and a dense embedding retrieval score are linearly combined to serve as a new ranking function.</p>
<h1 id="open-book-qa-retriever-generator">Open-book QA: Retriever-Generator<a hidden class="anchor" aria-hidden="true" href="#open-book-qa-retriever-generator">#</a></h1>
<p>Compared to the retriever-reader approach, the retriever-generator also has 2 stages but the second stage is to generate free text directly to answer the question rather than to extract start/end position in a retrieved passage. Some paper also refer to this as <em>Generative question answering</em>.</p>
<img src="QA-retiever-generator.png" style="width: 100%;" class="center" />
<figcaption>Fig. 11. The retriever + generator QA framework combines a document retrieval system with a general language model.</figcaption>
<p>A pretrained LM has a great capacity of memorizing knowledge in its parameters, as shown above. However, they cannot easily modify or expand their memory, cannot straightforwardly provide insights into their predictions, and may produce non-existent illusion.</p>
<p><a href="https://arxiv.org/abs/2005.04611">Petroni et al. (2020)</a> studied how the retrieved relevant context can help a generative language model produce better answers. They found:</p>
<ol>
<li>Augmenting queries with relevant contexts dramatically improves the pretrained LM on unsupervised machine reading capabilities.</li>
<li>An off-the-shelf IR system is sufficient for BERT to match the performance of a supervised ODQA baseline;</li>
<li>BERT&rsquo;s <a href="https://lilianweng.github.io/posts/2019-01-31-lm/#pre-training-tasks">NSP</a> pre-training strategy is a highly effective unsupervised mechanism in dealing with noisy and irrelevant contexts.</li>
</ol>
<p>They pair the BERT model with different types of context, including adversarial (unrelated context), retrieved (by BM25), and generative (by an autoregressive language model of 1.4N parameters, trained on CC-NEWS). The model is found to be robust to adversarial context, but only when the question and the context are provided as two segments (e.g. separated by <code>[SEP]</code>). One hypothesis is related to NSP task: &ldquo;BERT might learn to not condition across segments for masked token prediction if the NSP score is low, thereby implicitly detecting irrelevant and noisy contexts.&rdquo;</p>
<p><a name="RAG"></a><strong>RAG</strong> (&ldquo;Retrieval-Augmented Generation&rdquo;; <a href="https://arxiv.org/abs/2005.11401">Lewis et al., 2020</a>) combines pre-trained parametric (language model) and non-parametric memory (external knowledge index) together for language generation. RAG can be fine-tuned on any seq2seq task, whereby both the retriever and the sequence generator are jointly learned. They found that unconstrained generation outperforms previous extractive approaches.</p>
<p>RAG consists of a retriever model $p_\eta(z \vert x)$ and a generator model $p_\theta(y_i \vert x, z, y_{1:i-1})$:</p>
<ul>
<li>The retriever uses the input sequence $x$ to retrieve text passages $z$, implemented as a <a href="#DPR">DPR</a> retriever. $\log p_\eta(z \vert x) \propto E_z(z)^\top E_x(x)$.</li>
<li>The generator uses $z$ as additional context when generating the target sequence $y$, where the context and the question are simply concatenated.</li>
</ul>
<p>Depending on whether using the same or different retrieved documents for each token generation, there are two versions of RAG:</p>
<div>
$$
\begin{aligned}
p_\text{RAG-seq}(y \vert x) &= \sum_{z \in \text{TOP}_k(p_\eta(.\vert x))} p_\eta(z \vert x) \prod_i^N p_\theta(y_i \vert x, z, y_{1:i-1}) \\
p_\text{RAG-token}(y \vert x) &= \prod_i^N \sum_{z \in \text{TOP}_k(p_\eta(.\vert x))} p_\eta(z_i\vert x) p_\theta(y_i \vert x, z_i, y_{1:i-1})
\end{aligned}
$$
</div>
<p>The retriever + generator in RAG is jointly trained to minimize the NLL loss, $\mathcal{L}_\text{RAG} = \sum_j -\log p(y_j \vert x_j)$. Updating the passage encoder $E_z(.)$ is expensive as it requires the model to re-index the documents for fast MIPS. RAG does not find fine-tuning $E_z(.)$ necessary (like in <a href="#ORQA">ORQA</a>) and only updates the query encoder + generator.</p>
<img src="RAG.png" style="width: 100%;" class="center" />
<figcaption>Fig. 12. An illustration of retrieval-augmented generation (RAG) architecture. (Image source: <a href="https://arxiv.org/abs/2005.11401" target="_blank">Lewis et al., 2020</a>)</figcaption>
<p>At decoding/test time, RAG-token can be evaluated via a <a href="https://d2l.ai/chapter_recurrent-modern/beam-search.html#id1">beam search</a>. RAG-seq cannot be broken down into a set of per-token likelihood, so it runs beam search for each candidate document $z$ and picks the one with optimal $p_\theta(y_i \vert x, z, y_{1:i-1})$.</p>
<p>The <em>Fusion-in-Decoder</em> approach, proposed by <a href="https://arxiv.org/abs/2007.01282">Izacard &amp; Grave (2020)</a> is also based on a pre-trained T5. It works similar to RAG but differently for how the context is integrated into the decoder.</p>
<ol>
<li>Retrieve top $k$ related passage of 100 words each, using BM25 or DPR.</li>
<li>Each retrieved passage and its title are concatenated with the question using special tokens like <code>question:</code>, <code>title:</code> and <code>context:</code> to indicate the content differences.</li>
<li>Each retrieved passage is processed independently and later combined in the decoder. Processing passages independently in the encoder allows us to parallelize the computation. OTOH, processing them jointly encourages better aggregation of multiple pieces of evidence. The aggregation part is missing in extractive approaches.</li>
</ol>
<p>Note that they did fine-tune the pretrained LM independently for each dataset.</p>
<h1 id="closed-book-qa-generative-language-model">Closed-book QA: Generative Language Model<a hidden class="anchor" aria-hidden="true" href="#closed-book-qa-generative-language-model">#</a></h1>
<p>Big language models have been pre-trained on a large collection of unsupervised textual corpus. Given enough parameters, these models are able to memorize some factual knowledge within parameter weights. Therefore, we can use these models to do question-answering without explicit context, just like in a closed-book exam. The pre-trained language models produce <em>free text</em> to respond to questions, no explicit reading comprehension.</p>
<img src="LM-compute.png" style="width: 100%;" class="center" />
<figcaption>Fig. 13. The amount of computation used for training big language models of different sizes is getting big. (Image source: <a href="https://arxiv.org/abs/2005.14165" target="_blank">Brown et al., 2020</a>).</figcaption>
<p><a href="https://arxiv.org/abs/2002.08910">Roberts et al. (2020)</a> measured the practical utility of a language model by fine-tuning a pre-trained model to answer questions without access to any external context or knowledge. They fine-tuned the <a href="https://arxiv.org/abs/1910.10683">T5</a> language model (same architecture as the original Transformer) to answer questions without inputting any additional information or context. Such setup enforces the language model to answer questions based on &ldquo;knowledge&rdquo; that it internalized during pre-training.</p>
<img src="T5_SSM.png" style="width: 100%;" class="center" />
<figcaption>Fig. 14. T5 is first pre-trained with salient span masking and then fine-tuned for each QA dataset to produce answers in free text. (Image source: <a href="https://arxiv.org/abs/2002.08910" target="_blank">Roberts et al. 2020</a>)</figcaption>
<p>The original T5 models were pre-trained on a multi-task mixture including an unsupervised <a href="https://lilianweng.github.io/posts/2019-01-31-lm/#use-bert-in-downstream-tasks">&ldquo;masked language modeling&rdquo;</a> (MLM) tasks on the C4 (&ldquo;Colossal Clean Crawled Corpus&rdquo;) dataset as well as fine-tuned altogether with supervised translation, summarization, classification, and reading comprehension tasks. <a href="https://arxiv.org/abs/2002.08910">Roberts, et al. (2020)</a>  took a pre-trained T5 model and continued pre-training with <a href="#ssm">salient span masking</a> over Wikipedia corpus, which has been found to substantially boost the performance for ODQA. Then they fine-tuned the model for each QA datasets independently.</p>
<p>With a pre-trained T5 language model +  continue pre-training with salient spans masking + fine-tuning for each QA dataset,</p>
<ul>
<li>It can attain competitive results in open-domain question answering without access to external knowledge.</li>
<li>A larger model can obtain better performance. For example, a T5 with 11B parameters is able to match the performance with <a href="#DPR">DPR</a> with 3 BERT-base models, each with 330M parameters.</li>
</ul>
<p>Interestingly, fine-tuning is not strictly necessary. GPT3 (<a href="https://arxiv.org/abs/2005.14165">Brown et al., 2020</a>) has been evaluated on the closed book question answering task <em>without any gradient updates or fine-tuning</em>. During evaluation, the few-shot, one-shot and zero-shot settings here only refer to how many demonstrations are provided as context in the text input:</p>
<ol>
<li>&ldquo;few-shot learning&rdquo;: GPT3 is allowed to take as many demonstrations as what can fit into the model&rsquo;s context window (typically 10 to 100).</li>
<li>&ldquo;one-shot learning&rdquo;: only one demonstration is provided.</li>
<li>&ldquo;zero-shot learning&rdquo;: no demonstrations are allowed and only an instruction in natural language is given to the model.</li>
</ol>
<p>The performance grows with the model size. On the TriviaQA dataset, GPT3 evaluation with demonstrations can match or exceed the performance of SOTA baseline with fine-tuning.</p>
<img src="GPT3-triviaqa.png" style="width: 75%;" class="center" />
<figcaption>Fig. 15. GPT3's performance on TriviaQA grows smoothly with the model size. More demonstrations lead to better performance. (Image source: <a href="https://arxiv.org/abs/2005.14165" target="_blank">Brown et al., 2020</a>).</figcaption>
<p><a id="openai-api-example" ></a>Check out this cool example in OpenAI API <a href="https://beta.openai.com/playground/p/HMoho4552EHXrPLbmOIxpX4X">playground viewer</a>. The model is able to answer factal questions in short answer and not to make up things when the model does not know the answer. I added the last two questions and asked the model to respond with <code>A:</code>. The API is still in beta version, so you might need to <a href="https://beta.openai.com/">apply</a> to get on the wait list.</p>
<pre tabindex="0"><code>Q: Who is Batman?
A: Batman is a fictional comic book character.
##
Q: What is torsalplexity?
A: ?
##
Q: What is Devz9?
A: ?
##
Q: Who is George Lucas?
A: George Lucas is American film director and producer famous for creating Star Wars.
##
Q: What is the capital of California?
A: Sacramento.
##
Q: What orbits the Earth?
A: The Moon.
##
Q: Who is Fred Rickerson?
A: ?
##
Q: What is an atom?
A: An atom is a tiny particle that makes up everything.
##
Q: Who is Alvan Muntz?
A: ?
##
Q: What is Kozar-09?
A: ?
##
Q: How many moons does Mars have?
A: Two, Phobos and Deimos.
##
Q: What is COVID-19?
A: ?
##
Q: What is H1N1?
A: H1N1 is a strain of influenza.
</code></pre><h1 id="related-techniques">Related Techniques<a hidden class="anchor" aria-hidden="true" href="#related-techniques">#</a></h1>
<h2 id="fast-maximum-inner-product-search-mips">Fast Maximum Inner Product Search (MIPS)<a hidden class="anchor" aria-hidden="true" href="#fast-maximum-inner-product-search-mips">#</a></h2>
<p>MIPS (maximum inner product search) is a crucial component in many open-domain question answering models. In retriever + reader/generator framework, a large number of passages from the knowledge source are encoded and stored in a memory. A retrieval model is able to query the memory to identify the top relevant passages which have the maximum inner product with the question&rsquo;s embedding.</p>
<p>We need fast MIPS because the number of precomputed passage representations can be gigantic. There are several ways to achieve fast MIPS at run time, such as <a href="https://papers.nips.cc/paper/5329-asymmetric-lsh-alsh-for-sublinear-time-maximum-inner-product-search-mips.pdf">asymmetric LSH</a>, <a href="https://arxiv.org/abs/1501.01062">data-dependent hashing</a>,  and <a href="https://github.com/facebookresearch/faiss">FAISS</a>.</p>
<h2 id="language-model-pre-training">Language Model Pre-training<a hidden class="anchor" aria-hidden="true" href="#language-model-pre-training">#</a></h2>
<p>Two pre-training tasks are especially helpful for QA tasks, as we have discussed above.</p>
<ul>
<li>
<p><strong>Inverse Cloze Task</strong>  (proposed by <a href="#ORQA">ORQA</a>): The goal of <a href="https://en.wikipedia.org/wiki/Cloze_test">Cloze Task</a> is to predict masked-out text based on its context. The prediction of Inverse Cloze Task (ICT) is in the reverse direction, aiming to predict the context given a sentence. In the context of QA tasks, a random sentence can be treated as a pseudo-question, and its context can be treated as pseudo-evidence.</p>
</li>
<li>
<p><strong>Salient Spans Masking</strong> (proposed by <a href="#REALM">REALM</a>): Salient span masking is a special case for MLM task in language model training. First, we find <em>salient spans</em> by using a tagger to identify named entities and a regular expression to identify dates. Then one of the detected salient spans is selected and masked. The task is to predict this masked salient span.</p>
</li>
</ul>
<h1 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h1>
<table>
<thead>
<tr>
<th>Model</th>
<th>Retriever</th>
<th>Reader / Generator</th>
<th>Pre-training / Fine-tuning</th>
<th>End2end</th>
</tr>
</thead>
<tbody>
<tr>
<td>DrQA</td>
<td>TF-IDF</td>
<td>Bi-directional LSTM</td>
<td>&ndash;</td>
<td>No</td>
</tr>
<tr>
<td>BERTserini</td>
<td>Aserini + BM25</td>
<td>BERT without softmax layer</td>
<td>Fine-tune with SQuAD</td>
<td>No</td>
</tr>
<tr>
<td>Multi-passage BERT</td>
<td>ElasticSearch + BM25</td>
<td>Multi-passage BERT + Passage ranker</td>
<td></td>
<td>No</td>
</tr>
<tr>
<td>R^3</td>
<td>Classic IR + Match-LSTM</td>
<td>Match-LSTM</td>
<td></td>
<td>Yes</td>
</tr>
<tr>
<td>ORQA</td>
<td>Dot product of BERT embeddings</td>
<td>BERT-RC</td>
<td>Inverse cloze task</td>
<td>Yes</td>
</tr>
<tr>
<td>REALM</td>
<td>Dot product of BERT embeddings</td>
<td>BERT-RC</td>
<td>Salient span masking</td>
<td>Yes</td>
</tr>
<tr>
<td>DPR</td>
<td>Dot product of BERT embeddings</td>
<td>BERT-RC</td>
<td>supervised training with QA pairs</td>
<td>Yes</td>
</tr>
<tr>
<td>DenSPI</td>
<td>Classic + Neural IR</td>
<td>&ndash;</td>
<td></td>
<td>Yes</td>
</tr>
<tr>
<td>T5 + SSM</td>
<td>&ndash;</td>
<td>T5</td>
<td>SSM on <a href="https://commoncrawl.org/the-data/get-started/">CommonCrawl</a> data + Fine-tuning on QA data</td>
<td>Yes</td>
</tr>
<tr>
<td>GPT3</td>
<td>&ndash;</td>
<td>GPT3</td>
<td>NSP on <a href="https://commoncrawl.org/the-data/get-started/">CommonCrawl</a> data</td>
<td>Yes</td>
</tr>
<tr>
<td>RAG</td>
<td>DPR retriever</td>
<td><a href="https://arxiv.org/abs/1910.13461">BART</a></td>
<td></td>
<td>Yes</td>
</tr>
<tr>
<td>Fusion-in-Decoder</td>
<td>BM25 / DPR retriever</td>
<td>Tranformer</td>
<td></td>
<td>No</td>
</tr>
</tbody>
</table>
<img src="QA-results.png" style="width: 90%;" class="center" />
<figcaption>Fig. 16. A comparison of performance of several QA models on common QA datasets. On TriviaQA, two columns of results are reported, on the open domain test set (left) and on the hidden test set (right). (Image source: <a href="https://arxiv.org/abs/2007.01282" target="_blank">Izacard & Grave, 2020</a>).</figcaption>
<h1 id="citation">Citation<a hidden class="anchor" aria-hidden="true" href="#citation">#</a></h1>
<p>Cited as:</p>
<blockquote>
<p>Weng, Lilian. (Oct 2020). How to build an open-domain question answering system? Lil&rsquo;Log. https://lilianweng.github.io/posts/2020-10-29-odqa/.</p>
</blockquote>
<p>Or</p>
<pre tabindex="0"><code>@article{weng2020odqa,
  title   = &#34;How to Build an Open-Domain Question Answering System?&#34;,
  author  = &#34;Weng, Lilian&#34;,
  journal = &#34;lilianweng.github.io&#34;,
  year    = &#34;2020&#34;,
  month   = &#34;Oct&#34;
  url     = &#34;https://lilianweng.github.io/posts/2020-10-29-odqa/&#34;
}
</code></pre><h1 id="appendix-qa-datasets">Appendix: QA Datasets<a hidden class="anchor" aria-hidden="true" href="#appendix-qa-datasets">#</a></h1>
<ul>
<li><a href="https://rajpurkar.github.io/SQuAD-explorer/">SQuAD 2.0</a>: the Stanford QA dataset.</li>
<li><a href="http://www.qizhexie.com/data/RACE_leaderboard">RACE</a>: a reading comprehension dataset collected from English Examinations that are created for middle school and high school students.</li>
<li><a href="https://trec.nist.gov/data/qa.html">TREC QA</a>: the TREC QA collections.</li>
<li><a href="https://microsoft.github.io/msmarco/">MS MARCO</a>: a QA dataset featuring 100,000 real Bing questions and a human generated answer.</li>
<li><a href="https://github.com/brmson/dataset-factoid-curated">CuratedTREC</a>: based on the benchmarks from the TREC QA tasks that have been curated by <a href="https://link.springer.com/chapter/10.1007%2F978-3-319-24027-5_20">Baudis &amp; Sedivy (2015)</a>.</li>
<li><a href="https://ai.google.com/research/NaturalQuestions/dataset">Google Natural Questions</a>:  contains real user questions issued to Google search, and answers found from Wikipedia by annotators.</li>
<li><a href="https://github.com/brmson/dataset-factoid-webquestions">WebQuestions</a>: designed for knowledge-base QA with answers restricted to Freebase entities.</li>
<li><a href="https://www.microsoft.com/en-us/research/publication/wikiqa-a-challenge-dataset-for-open-domain-question-answering/">WikiQA</a>: Bing query logs were used as the source of questions. Each question is then linked to a Wikipedia page that potentially contains the answer.</li>
<li><a href="https://research.fb.com/downloads/babi/">WikiMovies</a>: contains movie-related questions from the OMDb and MovieLens databases and where the questions can be answered using Wikipedia pages.</li>
<li><a href="https://github.com/google-research-datasets/wiki-reading">WikiReading</a>: to predict textual values from the structured knowledge base Wikidata by reading the text of the corresponding Wikipedia articles.</li>
<li><a href="https://nlp.cs.washington.edu/triviaqa/">TriviaQA</a>: a reading comprehension dataset containing 95K question-answer pairs authored by trivia enthusiasts and independently gathered multiple evidence documents per question.</li>
<li><a href="https://www.kaggle.com/tunguz/200000-jeopardy-questions"> Jeopardy! Questions</a>: contains 200,000+ <a href="https://en.wikipedia.org/wiki/Jeopardy!">Jeopardy!</a> questions.</li>
<li><a href="https://cs.nyu.edu/~kcho/DMQA/">DeepMind Q&amp;A Dataset</a>: question/answer pairs from CNN and Daily Mail articles.</li>
<li><a href="https://research.fb.com/downloads/babi/">bAbi</a>: a rich collection of datasets for text understanding by Facebook.</li>
<li><a href="https://fever.ai/data.html">FEVER</a>: for fact extraction and verification.</li>
<li><a href="https://github.com/nyu-dl/dl4ir-searchQA">SearchQA</a>: question-answer pairs were crawled from from <a href="https://j-archive.com/"> J! Archive</a>, and then augmented with text snippets from Google.</li>
<li><a href="https://github.com/bdhingra/quasar">Quasar-T</a>: a collection of open-domain trivia questions and their answers obtained from various internet sources.</li>
<li><a href="https://people.cs.umass.edu/~miyyer/qblearn/index.html">Quiz bowl</a>: contains data from a trivia competition called quiz bowl.</li>
<li><a href="https://nlp.cs.washington.edu/ambigqa/">AmbigNQ</a>: ambiguous questions selected from NQ-OPEN dataset.</li>
<li><a href="https://github.com/facebookresearch/QA-Overlap">QA-Overlap</a>: a collections of overlapped answers/questions between train and test set for Natural Questions, TriviaQA, and WebQuestions.</li>
</ul>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Danqi Chen &amp; Scott Yih. <a href="https://github.com/danqi/acl2020-openqa-tutorial">&ldquo;ACL2020 Tutorial: Open-Domain Question Answering&rdquo;</a> July 2020.</p>
<p>[2] Danqi Chen, et al. <a href="https://arxiv.org/abs/1704.00051">&ldquo;Reading Wikipedia to Answer Open-Domain Questions&rdquo;</a> ACL 2017. | <a href="https://github.com/facebookresearch/DrQA">code</a></p>
<p>[3] Shuohang Wang, et al. <a href="https://arxiv.org/abs/1709.00023">&ldquo;R^3: Reinforced Ranker-Reader for Open-Domain Question Answering&rdquo;</a> AAAI 2018.</p>
<p>[4] Jimmy Lin. <a href="https://sigir.org/wp-content/uploads/2019/01/p040.pdf">&ldquo;The neural hype and comparisons against weak baselines.&rdquo;</a> ACM SIGIR Forum. Vol. 52. No. 2. 2019.</p>
<p>[5] Wei Yang, et al. <a href="https://arxiv.org/abs/1902.01718">&ldquo;End-to-End Open-Domain Question Answering with BERTserini&rdquo;</a> NAACL 2019.</p>
<p>[6] Christopher Clark &amp; Matt Gardner. <a href="https://arxiv.org/abs/1710.10723">&ldquo;Simple and Effective Multi-Paragraph Reading Comprehension.&rdquo;</a> arXiv:1710.10723 (2017).</p>
<p>[7] Rodrigo Nogueira &amp; Kyunghyun Cho. <a href="https://arxiv.org/abs/1901.04085">&ldquo;Passage Re-ranking with BERT.&rdquo;</a> arXiv preprint arXiv:1901.04085 (2019). | <a href="https://github.com/nyu-dl/dl4marco-bert">code</a></p>
<p>[8] Zhiguo Wang, et al. <a href="https://arxiv.org/abs/1908.08167">&ldquo;Multi-passage BERT: A globally normalized BERT model for open-domain question answering.&rdquo;</a> EMNLP 2019.</p>
<p>[9] Minjoon Seo et al. <a href="https://arxiv.org/abs/1906.05807">&ldquo;Real-time open-domain question answering with dense-sparse phrase index.&rdquo;</a> ACL 2019.</p>
<p>[10] Kenton Lee, et al. <a href="https://arxiv.org/abs/1906.00300">&ldquo;Latent Retrieval for Weakly Supervised Open Domain Question Answering&rdquo;</a> ACL 2019.</p>
<p>[11] Kelvin Guu, et al. <a href="https://arxiv.org/abs/2002.08909">&ldquo;REALM: Retrieval-Augmented Language Model Pre-Training&rdquo;</a> arXiv:2002.08909 (2020).</p>
<p>[12] Vladimir Karpukhin et al. <a href="https://arxiv.org/abs/2004.04906">&ldquo;Dense passage retrieval for open-domain question answering.&rdquo;</a>. EMNLP 2020. | <a href="https://github.com/facebookresearch/DPR">code</a></p>
<p>[13] Patrick Lewis et al. <a href="https://arxiv.org/abs/2005.11401">&ldquo;Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks&rdquo;</a> arXiv:2005.11401 (2020).</p>
<p>[14] Adam Roberts, et al. <a href="https://arxiv.org/abs/2002.08910">&ldquo;How Much Knowledge Can You Pack Into the Parameters of a Language Model?&rdquo;</a> EMNLP 2020.</p>
<p>[15] Tom Brown, et al. <a href="https://arxiv.org/abs/2005.14165">&ldquo;Language models are few-shot learners.&rdquo;</a> arXiv:2005.14165 (2020).</p>
<p>[16] Fabio Petroni, et al. <a href="https://arxiv.org/abs/2005.04611">&ldquo;How Context Affects Language Models&rsquo; Factual Predictions&rdquo;</a> AKBC 2020.</p>
<p>[17] Gautier Izacard &amp; Edouard Grave. <a href="https://arxiv.org/abs/2007.01282">&ldquo;Leveraging passage retrieval with generative models for open domain question answering.&rdquo;</a> arXiv:2007.01282 (2020).</p>
<p>[18] <a href="https://d2l.ai/chapter_recurrent-modern/beam-search.html">&ldquo;Dive into deep learning: Beam search&rdquo;</a></p>
<p>[19] Patrick Lewis, et al. <a href="https://arxiv.org/abs/2008.02637">&ldquo;Question and Answer Test-Train Overlap in Open-Domain Question Answering Datasets&rdquo;</a> arXiv:2008.02637 (2020). | <a href="https://github.com/facebookresearch/QA-Overlap">data</a></p>
<p>[20] Herv√© Jegou, et al. <a href="https://engineering.fb.com/2017/03/29/data-infrastructure/faiss-a-library-for-efficient-similarity-search/">&ldquo;Faiss: A library for efficient similarity search&rdquo;</a> Mar 2017.</p>
<p>[21] Vidhisha Balachandran, et al. <a href="https://arxiv.org/abs/2104.08710">&ldquo;Simple and Efficient ways to Improve REALM.&rdquo;</a> arXiv:2104.08710 (2021).</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lilianweng.github.io/tags/nlp/">nlp</a></li>
      <li><a href="https://lilianweng.github.io/tags/language-model/">language-model</a></li>
      <li><a href="https://lilianweng.github.io/tags/attention/">attention</a></li>
      <li><a href="https://lilianweng.github.io/tags/transformer/">transformer</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lilianweng.github.io/posts/2021-01-02-controllable-text-generation/">
    <span class="title">¬´ </span>
    <br>
    <span>Controllable Neural Text Generation</span>
  </a>
  <a class="next" href="https://lilianweng.github.io/posts/2020-08-06-nas/">
    <span class="title"> ¬ª</span>
    <br>
    <span>Neural Architecture Search</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on twitter"
        href="https://twitter.com/intent/tweet/?text=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f&amp;hashtags=nlp%2clanguage-model%2cattention%2ctransformer">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f&amp;title=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f&amp;summary=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f&amp;source=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f&title=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on whatsapp"
        href="https://api.whatsapp.com/send?text=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f%20-%20https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to Build an Open-Domain Question Answering System? on telegram"
        href="https://telegram.me/share/url?text=How%20to%20Build%20an%20Open-Domain%20Question%20Answering%20System%3f&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2020-10-29-odqa%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://lilianweng.github.io/">Lil&#39;Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
