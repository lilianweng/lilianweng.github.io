<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Diffusion Models for Video Generation | Lil&#39;Log</title>
<meta name="keywords" content="generative-model, video-generation" />
<meta name="description" content="Diffusion models have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task&mdash;using it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:

It has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model.
In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs.



ü•ë Required Pre-read: Please make sure you have read the previous blog on &ldquo;What are Diffusion Models?&rdquo; for image generation before continue here.
">
<meta name="author" content="Lilian Weng">
<link rel="canonical" href="https://lilianweng.github.io/posts/2024-04-12-diffusion-video/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.51b2420ff5ea1215cdf584af7ba59d5fea94201c33f25109d6448c7271631316.css" integrity="sha256-UbJCD/XqEhXN9YSve6WdX&#43;qUIBwz8lEJ1kSMcnFjExY=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lilianweng.github.io/favicon_wine.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lilianweng.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lilianweng.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lilianweng.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lilianweng.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://lilianweng.github.io/posts/2024-04-12-diffusion-video/" />
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFT45VFBX6"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-HFT45VFBX6');
        }
      </script><meta property="og:title" content="Diffusion Models for Video Generation" />
<meta property="og:description" content="Diffusion models have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task&mdash;using it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:

It has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model.
In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs.



ü•ë Required Pre-read: Please make sure you have read the previous blog on &ldquo;What are Diffusion Models?&rdquo; for image generation before continue here.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lilianweng.github.io/posts/2024-04-12-diffusion-video/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-12T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2024-04-12T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Diffusion Models for Video Generation"/>
<meta name="twitter:description" content="Diffusion models have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task&mdash;using it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:

It has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model.
In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs.



ü•ë Required Pre-read: Please make sure you have read the previous blog on &ldquo;What are Diffusion Models?&rdquo; for image generation before continue here.
"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://lilianweng.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Diffusion Models for Video Generation",
      "item": "https://lilianweng.github.io/posts/2024-04-12-diffusion-video/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Diffusion Models for Video Generation",
  "name": "Diffusion Models for Video Generation",
  "description": "Diffusion models have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task\u0026mdash;using it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:\nIt has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model. In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs. ü•ë Required Pre-read: Please make sure you have read the previous blog on \u0026ldquo;What are Diffusion Models?\u0026rdquo; for image generation before continue here. ",
  "keywords": [
    "generative-model", "video-generation"
  ],
  "articleBody": "Diffusion models have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task‚Äîusing it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:\nIt has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model. In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs. ü•ë Required Pre-read: Please make sure you have read the previous blog on ‚ÄúWhat are Diffusion Models?‚Äù for image generation before continue here. Video Generation Modeling from Scratch First let‚Äôs review approaches for designing and training diffusion video models from scratch, meaning that we do not rely on pre-trained image generators.\nParameterization \u0026 Sampling Basics Here we use a slightly different variable definition from the previous post, but the math stays the same. Let $\\mathbf{x} \\sim q_\\text{real}$ be a data point sampled from the real data distribution. Now we are adding Gaussian noise in small amount in time, creating a sequence of noisy variations of $\\mathbf{x}$, denoted as $\\{\\mathbf{z}_t \\mid t =1 \\dots, T\\}$, with increasing amount of noise as $t$ increases and the last $q(\\mathbf{z}_T) \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$. The noise-adding forward process is a Gaussian process. Let $\\alpha_t, \\sigma_t$ define a differentiable noise schedule of the Gaussian process:\n$$ q(\\mathbf{z}_t \\vert \\mathbf{x}) = \\mathcal{N}(\\mathbf{z}_t; \\alpha_t \\mathbf{x}, \\sigma^2_t\\mathbf{I}) $$ To represent $q(\\mathbf{z}_t \\vert \\mathbf{z}_s)$ for $0 \\leq s \u003c t \\leq T$, we have:\n$$ \\begin{aligned} \\mathbf{z}_t \u0026= \\alpha_t \\mathbf{x} + \\sigma_t\\boldsymbol{\\epsilon}_t \\\\ \\mathbf{z}_s \u0026= \\alpha_s \\mathbf{x} + \\sigma_s\\boldsymbol{\\epsilon}_s \\\\ \\mathbf{z}_t \u0026= \\alpha_t \\Big(\\frac{\\mathbf{z}_s - \\sigma_s\\boldsymbol{\\epsilon}_s}{\\alpha_s}\\Big) + \\sigma_t\\boldsymbol{\\epsilon}_t \\\\ \\mathbf{z}_t \u0026= \\frac{\\alpha_t}{\\alpha_s}\\mathbf{z}_s + \\sigma_t\\boldsymbol{\\epsilon}_t - \\frac{\\alpha_t\\sigma_s}{\\alpha_s} \\boldsymbol{\\epsilon}_s \\\\ \\text{Thus }q(\\mathbf{z}_t \\vert \\mathbf{z}_s) \u0026= \\mathcal{N}\\Big(\\mathbf{z}_t; \\frac{\\alpha_t}{\\alpha_s}\\mathbf{z}_s, \\big(1 - \\frac{\\alpha^2_t\\sigma^2_s}{\\sigma^2_t\\alpha^2_s}\\big)\\sigma^2_t \\mathbf{I}\\Big) \\end{aligned} $$ Let the log signal-to-noise-ratio be $\\lambda_t = \\log[\\alpha^2_t / \\sigma^2_t]$, we can represent the DDIM (Song et al. 2020) update as:\n$$ q(\\mathbf{z}_t \\vert \\mathbf{z}_s) = \\mathcal{N}\\Big(\\mathbf{z}_t; \\frac{\\alpha_t}{\\alpha_s}\\mathbf{z}_s, \\sigma^2_{t\\vert s} \\mathbf{I}\\Big) \\quad \\text{where }\\sigma^2_{t\\vert s} = (1 - e^{\\lambda_t - \\lambda_s})\\sigma^2_t $$ There is a special $\\mathbf{v}$-prediction ($\\mathbf{v} = \\alpha_t \\boldsymbol{\\epsilon} - \\sigma_t \\mathbf{x}$) parameterization, proposed by Salimans \u0026 Ho (2022). It has been shown to be helpful for avoiding color shift in video generation compared to $\\boldsymbol{\\epsilon}$-parameterization.\nThe $\\mathbf{v}$-parameterization is derived with a trick in the angular coordinate. First, we define $\\phi_t = \\arctan(\\sigma_t / \\alpha_t)$ and thus we have $\\alpha_\\phi = \\cos\\phi, \\sigma_t = \\sin\\phi, \\mathbf{z}_\\phi = \\cos\\phi \\mathbf{x} + \\sin\\phi\\boldsymbol{\\epsilon}$. The velocity of $\\mathbf{z}_\\phi$ can be written as:\n$$ \\mathbf{v}_\\phi = \\nabla_\\phi \\mathbf{z}_\\phi = \\frac{d\\cos\\phi}{d\\phi} \\mathbf{x} + \\frac{d\\sin\\phi}{d\\phi}\\boldsymbol{\\epsilon} = \\cos\\phi\\boldsymbol{\\epsilon} -\\sin\\phi\\mathbf{x} $$ Then we can infer,\n$$ \\begin{aligned} \\sin\\phi\\mathbf{x} \u0026= \\cos\\phi\\boldsymbol{\\epsilon} - \\mathbf{v}_\\phi \\\\ \u0026= \\frac{\\cos\\phi}{\\sin\\phi}\\big(\\mathbf{z}_\\phi - \\cos\\phi\\mathbf{x}\\big) - \\mathbf{v}_\\phi \\\\ \\sin^2\\phi\\mathbf{x} \u0026= \\cos\\phi\\mathbf{z}_\\phi - \\cos^2\\phi\\mathbf{x} - \\sin\\phi \\mathbf{v}_\\phi \\\\ \\mathbf{x} \u0026= \\cos\\phi\\mathbf{z}_\\phi - \\sin\\phi\\mathbf{v}_\\phi \\\\ \\text{Similarly } \\boldsymbol{\\epsilon} \u0026= \\sin\\phi\\mathbf{z}_\\phi + \\cos\\phi \\mathbf{v}_\\phi \\end{aligned} $$ The DDIM update rule is updated accordingly,\n$$ \\begin{aligned} \\mathbf{z}_{\\phi_s} \u0026= \\cos\\phi_s\\hat{\\mathbf{x}}_\\theta(\\mathbf{z}_{\\phi_t}) + \\sin\\phi_s\\hat{\\epsilon}_\\theta(\\mathbf{z}_{\\phi_t}) \\quad\\quad{\\small \\text{; }\\hat{\\mathbf{x}}_\\theta(.), \\hat{\\epsilon}_\\theta(.)\\text{ are two models to predict }\\mathbf{x}, \\boldsymbol{\\epsilon}\\text{ based on }\\mathbf{z}_{\\phi_t}}\\\\ \u0026= \\cos\\phi_s \\big( \\cos\\phi_t \\mathbf{z}_{\\phi_t} - \\sin\\phi_t \\hat{\\mathbf{v}}_\\theta(\\mathbf{z}_{\\phi_t} ) \\big) + \\sin\\phi_s \\big( \\sin\\phi_t \\mathbf{z}_{\\phi_t} + \\cos\\phi_t \\hat{\\mathbf{v}}_\\theta(\\mathbf{z}_{\\phi_t} ) \\big) \\\\ \u0026= {\\color{red} \\big( \\cos\\phi_s\\cos\\phi_t + \\sin\\phi_s\\sin\\phi_t \\big)} \\mathbf{z}_{\\phi_t} + {\\color{green} \\big( \\sin\\phi_s \\cos\\phi_t - \\cos\\phi_s \\sin\\phi_t \\big)} \\hat{\\mathbf{v}}_\\theta(\\mathbf{z}_{\\phi_t} ) \\\\ \u0026= {\\color{red} cos(\\phi_s - \\phi_t)} \\mathbf{z}_{\\phi_t} + {\\color{green} \\sin(\\phi_s - \\phi_t)} \\hat{\\mathbf{v}}_\\theta(\\mathbf{z}_{\\phi_t}) \\quad\\quad{\\small \\text{; trigonometric identity functions.}} \\end{aligned} $$ Visualizing how the diffusion update step works in the angular coordinate, where DDIM evolves $\\mathbf{z}_{\\phi_s}$ by moving it along the $-\\hat{\\mathbf{v}}_{\\phi_t}$ direction. (Image source: Salimans \u0026 Ho, 2022) The $\\mathbf{v}$-parameterization for the model is to predict $\\mathbf{v}_\\phi = \\cos\\phi\\boldsymbol{\\epsilon} -\\sin\\phi\\mathbf{x} = \\alpha_t\\boldsymbol{\\epsilon} - \\sigma_t\\mathbf{x}$.\nIn the case of video generation, we need the diffusion model to run multiple steps of upsampling for extending video length or increasing the frame rate. This requires the capability of sampling a second video $\\mathbf{x}^b$ conditioned on the first $\\mathbf{x}^a$, $\\mathbf{x}^b \\sim p_\\theta(\\mathbf{x}^b \\vert \\mathbf{x}^a)$, where $\\mathbf{x}^b$ might be an autoregressive extension of $\\mathbf{x}^a$ or be the missing frames in-between for a video $\\mathbf{x}^a$ at a low frame rate.\nThe sampling of $\\mathbf{x}_b$ needs to condition on $\\mathbf{x}_a$ besides its own corresponding noisy variable. Video Diffusion Models (VDM; Ho \u0026 Salimans, et al. 2022) proposed the reconstruction guidance method using an adjusted denoising model such that the sampling of $\\mathbf{x}^b$ can be properly conditioned on $\\mathbf{x}^a$:\n$$ \\begin{aligned} \\mathbb{E}_q [\\mathbf{x}_b \\vert \\mathbf{z}_t, \\mathbf{x}^a] \u0026= \\mathbb{E}_q [\\mathbf{x}^b \\vert \\mathbf{z}_t] + \\frac{\\sigma_t^2}{\\alpha_t} \\nabla_{\\mathbf{z}^b_t} \\log q(\\mathbf{x}^a \\vert \\mathbf{z}_t) \\\\ q(\\mathbf{x}^a \\vert \\mathbf{z}_t) \u0026\\approx \\mathcal{N}\\big[\\hat{\\mathbf{x}}^a_\\theta (\\mathbf{z}_t), \\frac{\\sigma_t^2}{\\alpha_t^2}\\mathbf{I}\\big] \u0026 {\\small \\text{; the closed form is unknown.}}\\\\ \\tilde{\\mathbf{x}}^b_\\theta (\\mathbf{z}_t) \u0026= \\hat{\\mathbf{x}}^b_\\theta (\\mathbf{z}_t) - \\frac{w_r \\alpha_t}{2} \\nabla_{\\mathbf{z}_t^b} \\| \\mathbf{x}^a - \\hat{\\mathbf{x}}^a_\\theta (\\mathbf{z}_t) \\|^2_2 \u0026 {\\small \\text{; an adjusted denoising model for }\\mathbf{x}^b} \\end{aligned} $$ where $\\hat{\\mathbf{x}}^a_\\theta (\\mathbf{z}_t), \\hat{\\mathbf{x}}^b_\\theta (\\mathbf{z}_t)$ are reconstructions of $\\mathbf{x}^a, \\mathbf{x}^b$ provided by the denoising model. And $w_r$ is a weighting factor and a large one $w_r \u003e1$ is found to improve sample quality. Note that it is also possible to simultaneously condition on low resolution videos to extend samples to be at the high resolution using the same reconstruction guidance method.\nModel Architecture: 3D U-Net \u0026 DiT Similar to text-to-image diffusion models, U-net and Transformer are still two common architecture choices. There are a series of diffusion video modeling papers from Google based on the U-net architecture and a recent Sora model from OpenAI leveraged the Transformer architecture.\nVDM (Ho \u0026 Salimans, et al. 2022) adopts the standard diffusion model setup but with an altered architecture suitable for video modeling. It extends the 2D U-net to work for 3D data (Cicek et al. 2016), where each feature map represents a 4D tensor of frames x height x width x channels. This 3D U-net is factorized over space and time, meaning that each layer only operates on the space or time dimension, but not both:\nProcessing Space: Each old 2D convolution layer as in the 2D U-net is extended to be space-only 3D convolution; precisely, 3x3 convolutions become 1x3x3 convolutions. Each spatial attention block remains as attention over space, where the first axis (frames) is treated as batch dimension. Processing Time: A temporal attention block is added after each spatial attention block. It performs attention over the first axis (frames) and treats spatial axes as the batch dimension. The relative position embedding is used for tracking the order of frames. The temporal attention block is important for the model to capture good temporal coherence. The 3D U-net architecture. The noisy video $\\mathbf{z}_t$ , conditioning information $\\boldsymbol{c}$ and the log signal-to-noise ratio (log-SNR) $\\lambda_t$ are inputs to the network. The channel multipliers $M_1, \\dots, M_K$ represent the channel counts across layers. (Image source: Salimans \u0026 Ho, 2022) Imagen Video (Ho, et al. 2022) is constructed on a cascade of diffusion models to enhance the video generation quality and upgrades to output 1280x768 videos at 24 fps. The Imagen Video architecture consists of the following components, counting 7 diffusion models in total.\nA frozen T5 text encoder to provide text embedding as the conditioning input. A base video diffusion model. A cascade of interleaved spatial and temporal super-resolution diffusion models, including 3 TSR (Temporal Super-Resolution) and 3 SSR (Spatial Super-Resolution) components. The cascaded sampling pipeline in Imagen Video. In practice, the text embeddings are injected into all components, not just the base model. (Image source: Ho et al. 2022) The base denoising models performs spatial operations over all the frames with shared parameters simultaneously and then the temporal layer mixes activations across frames to better capture temporal coherence, which is found to work better than frame-autoregressive approaches.\nThe architecture of one space-time separable block in the Imagen Video diffusion model. (Image source: Ho et al. 2022) Both SSR and TSR models condition on the upsampled inputs concatenated with noisy data $\\mathbf{z}_t$ channel-wise. SSR upsamples by bilinear resizing, while TSR upsamples by repeating the frames or filling in blank frames.\nImagen Video also applies progressive distillation to speed up sampling and each distillation iteration can reduce the required sampling steps by half. Their experiments were able to distill all 7 video diffusion models down to just 8 sampling steps per model without any noticeable loss in perceptual quality.\nTo achieve better scaling efforts, Sora (Brooks et al. 2024) leverages DiT (Diffusion Transformer) architecture that operates on spacetime patches of video and image latent codes. Visual input is represented as a sequence of spacetime patches which act as Transformer input tokens.\nSora is a diffusion transformer model.(Image source: Brooks et al. 2024) Adapting Image Models to Generate Videos Another prominent approach for diffusion video modeling is to ‚Äúinflate‚Äù a pre-trained image-to-text diffusion model by inserting temporal layers and then we can choose to only fine-tune new layers on video data, or avoid extra training at all. The prior knowledge of text-image pairs is inherited by the new model and thus it can help alleviate the requirement on text-video pair data.\nFine-tuning on Video Data Make-A-Video (Singer et al. 2022) extends a pre-trained diffusion image model with a temporal dimension, consisting of three key components:\nA base text-to-image model trained on text-image pair data. Spatiotemporal convolution and attention layers to extend the network to cover temporal dimension. A frame interpolation network for high frame rate generation The illustration of Make-A-Video pipeline.(Image source: Singer et al. 2022) The final video inference scheme can be formulated as:\n$$ \\hat{\\mathbf{y}}_t = \\text{SR}_h \\circ \\text{SR}^t_l \\circ \\uparrow_F \\circ D^t \\circ P \\circ (\\hat{\\mathbf{x}}, \\text{CLIP}_\\text{text}(\\mathbf{x})) $$ where:\n$\\mathbf{x}$ is the input text. $\\hat{\\mathbf{x}}$ is the BPE-encoded text. $\\text{CLIP}_\\text{text}(.)$ is the CLIP text encoder, $\\mathbf{x}_e = \\text{CLIP}_\\text{text}(\\mathbf{x})$. $P(.)$ is the prior, generating image embedding $\\mathbf{y}_e$ given text embedding $\\mathbf{x}_e$ and BPE encoded text $\\hat{\\mathbf{x}}$ : $\\mathbf{y}_e = P(\\mathbf{x}_e, \\hat{\\mathbf{x}})$. This part is trained on text-image pair data and not fine-tuned on video data. $D^t(.)$ is the spatiotemporal decoder that generates a series of 16 frames, where each frame is a low-resolution 64x64 RGB image $\\hat{\\mathbf{y}}_l$. $\\uparrow_F(.)$ is the frame interpolation network, increasing the effective frame rate by interpolating between generated frames. This is a fine-tuned model for the task of predicting masked frames for video upsampling. $\\text{SR}_h(.), \\text{SR}^t_l(.)$ are the spatial and spatiotemporal super-resolution models, increasing the image resolution to 256x256 and 768x768, respectively. $\\hat{\\mathbf{y}}_t$ is the final generated video. Spatiotemporal SR layers contain pseudo-3D convo layers and pseudo-3D attention layers:\nPseudo-3D convo layer : Each spatial 2D convo layer (initialized from the pre-training image model) is followed by a temporal 1D layer (initialized as the identity function). Conceptually, the convo 2D layer first generates multiple frames and then frames are reshaped to be a video clip. Pseudo-3D attention layer: Following each (pre-trained) spatial attention layer, a temporal attention layer is stacked and used to approximate a full spatiotemporal attention layer. How pseudo-3D convolution (left) and attention (right) layers work.(Image source: Singer et al. 2022) They can be represented as:\n$$ \\begin{aligned} \\text{Conv}_\\text{P3D} \u0026= \\text{Conv}_\\text{1D}(\\text{Conv}_\\text{2D}(\\mathbf{h}) \\circ T) \\circ T \\\\ \\text{Attn}_\\text{P3D} \u0026= \\text{flatten}^{-1}(\\text{Attn}_\\text{1D}(\\text{Attn}_\\text{2D}(\\text{flatten}(\\mathbf{h})) \\circ T) \\circ T) \\end{aligned} $$ where an input tensor $\\mathbf{h} \\in \\mathbb{R}^{B\\times C \\times F \\times H \\times W}$ (corresponding to batch size, channels, frames, height and weight); and $\\circ T$ swaps between temporal and spatial dimensions; $\\text{flatten}(.)$ is a matrix operator to convert $\\mathbf{h}$ to be $\\mathbf{h}‚Äô \\in \\mathbb{R}^{B \\times C \\times F \\times HW}$ and $\\text{flatten}^{-1}(.)$ reverses that process.\nDuring training, different components of Make-A-Video pipeline are trained independently.\nDecoder $D^t$, prior $P$ and two super-resolution components $\\text{SR}_h, \\text{SR}^t_l$ are first trained on images alone, without paired text. Next the new temporal layers are added, initialized as identity function, and then fine-tuned on unlabeled video data. Tune-A-Video (Wu et al. 2023) inflates a pre-trained image diffusion model to enable one-shot video tuning: Given a video containing $m$ frames, $\\mathcal{V} = \\{v_i \\mid i = 1, \\dots, m\\}$, paired with a descriptive prompt $\\tau$, the task is to generate a new video $\\mathcal{V}^*$ based on a slightly edited \u0026 related text prompt $\\tau^*$. For example, $\\tau$ = \"A man is skiing\" can be extended to $\\tau^*$=\"Spiderman is skiing on the beach\". Tune-A-Video is meant to be used for object editing, background change, and style transfer.\nBesides inflating the 2D convo layer, the U-Net architecture of Tune-A-Video incorporates the ST-Attention (spatiotemporal attention) block to capture temporal consistency by querying relevant positions in previous frames. Given latent features of frame $v_i$, previous frames $v_{i-1}$ and the first frame $v_1$ are projected to query $\\mathbf{Q}$, key $\\mathbf{K}$ and value $\\mathbf{V}$, the ST-attention is defined as:\n$$ \\begin{aligned} \u0026\\mathbf{Q} = \\mathbf{W}^Q \\mathbf{z}_{v_i}, \\quad \\mathbf{K} = \\mathbf{W}^K [\\mathbf{z}_{v_1}, \\mathbf{z}_{v_{i-1}}], \\quad \\mathbf{V} = \\mathbf{W}^V [\\mathbf{z}_{v_1}, \\mathbf{z}_{v_{i-1}}] \\\\ \u0026\\mathbf{O} = \\text{softmax}\\Big(\\frac{\\mathbf{Q} \\mathbf{K}^\\top}{\\sqrt{d}}\\Big) \\cdot \\mathbf{V} \\end{aligned} $$ The Tune-A-Video architecture overview. It first runs a light-weighted fine-tuning stage on a single video before the sampling stage. Note that the entire temporal self-attention (T-Attn) layers get fine-tuned because they are newly added, but only query projections in ST-Attn and Cross-Attn are updated during fine-tuning to preserve prior text-to-image knowledge. ST-Attn improves spatial-temporal consistency, Cross-Attn refines text-video alignment. (Image source: Wu et al. 2023) Gen-1 model (Esser et al. 2023) by Runway targets the task of editing a given video according to text inputs. It decomposes the consideration of structure and content of a video $p(\\mathbf{x} \\mid s, c)$ for generation conditioning. However, to do a clear decomposition of these two aspects is not easy.\nContent $c$ refers to appearance and semantics of the video, that is sampled from the text for conditional editing. CLIP embedding of the frame is a good representation of content, and stays largely orthogonal to structure traits. Structure $s$ depicts greometry and dynamics, including shapes, locations, temporal changes of objects, and $s$ is sampled from the input video. Depth estimation or other task-specific side information (e.g. human body pose or face landmarks for human video synthesis) can be used. The architecture changes in Gen-1 are quite standard, i.e. adding 1D temporal convo layer after each 2D spatial convo layer in its residual blocks and adding 1D temporal attention block after each 2D spatial attention block in its attention blocks. During training, the structure variable $s$ is concatenated with the diffusion latent variable $\\mathbf{z}$, where the content variable $c$ is provided in the cross-attention layer. At inference time, the clip embedding is converted via a prior to convert CLIP text embedding to be CLIP image embedding.\nThe overview of the Gen-1 model training pipeline.(Image source: Esser et al. 2023) Video LDM (Blattmann et al. 2023) trains a LDM (Latent diffusion models) image generator first. Then the model is fine-tuned to produce videos with a temporal dimension added. The fine-tuning only applies to these newly added temporal layers on encoded image sequences. The temporal layers $\\{l^i_\\phi \\mid i = \\ 1, \\dots, L\\}$ in the Video LDM (See Fig. 10) are interleaved with existing spatial layers $l^i_\\theta$ which stays frozen during fine-tuning. That‚Äôs being said, we only fine-tune the new parameters $\\phi$ but not the pre-trained image backbone model parameters $\\theta$. The pipeline of Video LDM first generates key frames at low fps and then processes through 2 steps of latent frame interpolations to increase fps.\nThe input sequence of length $T$ is interpreted as a batch of images (i.e. $B \\cdot T$) for the base image model $\\theta$ and then gets reshaped into video format for $l^i_\\phi$ temporal layers. There is a skip connection leads to a combination of temporal layer output $\\mathbf{z}‚Äô$ and the spatial output $\\mathbf{z}$ via a learned merging parameter $\\alpha$. There are two types of temporal mixing layers implemented in practice: (1) temporal attention and (2) residual blocks based on 3D convolutions.\nA pre-training LDM for image synthesis is extended to be a video generator. $B, T, C, H, W$ are batch size, sequence length, channels, height and width, respectively. $\\mathbf{c}_S$ is an optional conditioning/context frame. (Image source: Blattmann et al. 2023) However, there is a remaining issue with LDM‚Äôs pretrainined autoencoder which only sees images never videos. Naively using that for video generation can cause flickering artifacts without good temporal coherence. So Video LDM adds additional temporal layers into the decoder and fine-tuned on video data with a patch-wise temporal discriminator built from 3D convolutions, while the encoder remains unchanged so that we still can reuse the pretrained LDM. During temporal decoder fine-tuning, the frozen encoder processes each frame in the video independently, and enforce temporally coherent reconstructions across frames with a video-aware discriminator.\nThe training pipeline of autoencoder in video latent diffusion models. The decoder is fine-tuned to have temporal coherency with a new across-frame discriminator while the encoder stays frozen. (Image source: Blattmann et al. 2023) Similar to Video LDM, the architecture design of Stable Video Diffusion (SVD; Blattmann et al. 2023) is also based on LDM with temporal layers inserted after every spatial convolution and attention layer, but SVD fine-tunes the entire model. There are three stages for training video LDMs:\nText-to-image pretraining is important and helps improve both quality and prompt following. Video pretraining is beneficial to be separated and should ideally occur on a larger scale, curated dataset. High-quality video finetuning works with a smaller, pre-captioned video of high visual fidelity. SVD specially emphasizes the critical role of dataset curation in model performance. They applied a cut detection pipeline to get more cuts per video and then applied three different captioner models: (1) CoCa for mid-frame, (2) V-BLIP for a video caption, and (3) LLM based captioning based on previous two captions. Then they were able to continue to improve video datasets, by removing clips with less motion (filtered by low optical flow scores calculated at 2 fps), excessive text presence (apply optical character recognition to identify videos with lots of text), or generally low aesthetic value (annotate the first, middle, and last frames of each clip with CLIP embeddings and calculate aesthetics scores \u0026 text-image similarities). The experiments showed that a filtered, higher quality dataset leads to better model quality, even when this dataset is much smaller.\nThe key challenge of generating distant key frames first and then adding interpolation with temporal super-resolution is how to maintain high-quality temporal consistency. Lumiere (Bar-Tal et al. 2024) instead adopts a space-time U-Net (STUNet) architecture that generates the entire temporal duration of the video at once through a single pass, removing the dependency on TSR (temporal super-resolution) components. STUNet downsamples the video in both time and space dimensions and thus expensive computation happens in a compact time-space latent space.\nLumiere removes TSR (temporal super-resolution) models. The inflated SSR network can operate only on short segments of the video due to memory constraints and thus SSR models operate on a set of shorter but overlapped video snippets. (Image source: Bar-Tal et al. 2024) STUNet inflates a pretrained text-to-image U-net to be able to downsample and upsample videos at both time and space dimensions. Convo-based blocks consist of pre-trained text-to-image layers, followed by a factorized space-time convolution. And attention-based blocks at the coarsest U-Net level contains the pre-trained text-to-image, followed by temporal attention. Further training only happens with the newly added layers.\nThe architecture of (a) Space-Time U-Net (STUNet), (b) the convolution-based block, and (c) the attention-based block. (Image source: Bar-Tal et al. 2024) Training-Free Adaptation Somehow surprisingly, it is possible to adapt a pre-trained text-to-image model to output videos without any training ü§Ø.\nIf we naively sample a sequence of latent codes at random and then construct a video of decoded corresponding images, there is no guarantee in the consistency in objects and semantics in time. Text2Video-Zero (Khachatryan et al. 2023) enables zero-shot, training-free video generation by enhancing a pre-trained image diffusion model with two key mechanisms for temporal consistency:\nSampling the sequence of latent codes with motion dynamics to keep the global scene and the background time consistent; Reprogramming frame-level self-attention using a new cross-frame attention of each frame on the first frame, to preserve the context, appearance, and identity of the foreground object. An overview of the Text2Video-Zero pipeline. (Image source: Khachatryan et al. 2023) The process of sampling a sequence of latent variables, $\\mathbf{x}^1_T, \\dots, \\mathbf{x}^m_T$, with motion information is described as follows:\nDefine a direction $\\boldsymbol{\\delta} = (\\delta_x, \\delta_y) \\in \\mathbb{R}^2$ for controlling the global scene and camera motion; by default, we set $\\boldsymbol{\\delta} = (1, 1)$. Also define a hyperparameter $\\lambda \u003e 0$ controlling the amount of global motion. First sample the latent code of the first frame at random, $\\mathbf{x}^1_T \\sim \\mathcal{N}(0, I)$; Perform $\\Delta t \\geq 0$ DDIM backward update steps using the pre-trained image diffusion model, e.g. Stable Diffusion (SD) model in the paper, and obtain the corresponding latent code $\\mathbf{x}^1_{T‚Äô}$ where $T‚Äô = T - \\Delta t$. For each frame in the latent code sequence, we apply corresponding motion translation with a warping operation defined by $\\boldsymbol{\\delta}^k = \\lambda(k-1)\\boldsymbol{\\delta}$ to obtain $\\tilde{\\mathbf{x}}^k_{T‚Äô}$. Finally apply DDIM forward steps to all $\\tilde{\\mathbf{x}}^{2:m}_{T‚Äô}$ to obtain $\\mathbf{x}^{2:m}_T$. $$ \\begin{aligned} \\mathbf{x}^1_{T'} \u0026= \\text{DDIM-backward}(\\mathbf{x}^1_T, \\Delta t)\\text{ where }T' = T - \\Delta t \\\\ W_k \u0026\\gets \\text{a warping operation of }\\boldsymbol{\\delta}^k = \\lambda(k-1)\\boldsymbol{\\delta} \\\\ \\tilde{\\mathbf{x}}^k_{T'} \u0026= W_k(\\mathbf{x}^1_{T'})\\\\ \\mathbf{x}^k_T \u0026= \\text{DDIM-forward}(\\tilde{\\mathbf{x}}^k_{T'}, \\Delta t)\\text{ for }k=2, \\dots, m \\end{aligned} $$ Besides, Text2Video-Zero replaces the self-attention layer in a pre-trained SD model with a new cross-frame attention mechanism with reference to the first frame. The motivation is to preserve the information about the foreground object‚Äôs appearance, shape, and identity throughout the generated video.\n$$ \\text{Cross-Frame-Attn}(\\mathbf{Q}^k, \\mathbf{K}^{1:m}, \\mathbf{V}^{1:m}) = \\text{Softmax}\\Big( \\frac{\\mathbf{Q}^k (\\mathbf{K}^1)^\\top}{\\sqrt{c}} \\Big) \\mathbf{V}^1 $$ Optionally, the background mask can be used to further smoothen and improve background consistency. Let‚Äôs say, we obtain a corresponding foreground mask $\\mathbf{M}_k$ for the $k$-th frame using some existing method, and background smoothing merges the actual and the warped latent code at the diffusion step $t$, w.r.t. the background matrix:\n$$ \\bar{\\mathbf{x}}^k_t = \\mathbf{M}^k \\odot \\mathbf{x}^k_t + (1 ‚àí \\mathbf{M}^k) \\odot (\\alpha\\tilde{\\mathbf{x}}^k_t +(1‚àí\\alpha)\\mathbf{x}^k_t)\\quad\\text{for }k=1, \\dots, m $$ where $\\mathbf{x}^k_t$ is the actual latent code and $\\tilde{\\mathbf{x}}^k_t$ is the warped latent code on the background; $\\alpha$ is a hyperparameter and the papers set $\\alpha=0.6$ in the experiments.\nText2video-zero can be combined with ControlNet where the ControlNet pretrained copy branch is applied per frame on each $\\mathbf{x}^k_t$ for $k = 1, \\dots, m$ in each diffusion time-step $t = T , \\dots, 1$ and add the ControlNet branch outputs to the skip-connections of the main U-net.\nControlVideo (Zhang et al. 2023) aims to generate videos conditioned on text prompt $\\tau$ and a motion sequence (e.g., depth or edge maps), $\\mathbf{c} = \\{c^i\\}_{i=0}^{N-1}$. It is adapted from ControlNet with three new mechanisms added:\nCross-frame attention: Adds fully cross-frame interaction in self-attention modules. It introduces interactions between all the frames, by mapping the latent frames at all the time steps into $\\mathbf{Q}, \\mathbf{K}, \\mathbf{V}$ matrices, different from Text2Video-zero which only configures all the frames to attend to the first frame. Interleaved-frame smoother is a mechanism to employ frame interpolation on alternated frames to reduce the flickering effect. At each time step $t$, the smoother interpolates the even or odd frames to smooth their corresponding three-frame clips. Note that the number of frames decreases in time after smoothing steps. Hierarchical sampler utilizes a hierarchical sampler to enable long videos with time consistency under memory constraints. A long video is split into multiple short clips and each has a key frame selected. The model pre-generates these keyframes with full cross-frame attention for long-term coherency and each corresponding short clip is synthesized sequentially conditioned on the keyframes. The overview of ControlVideo. (Image source: Zhang et al. 2023) Citation Cited as:\nWeng, Lilian. (Apr 2024). Diffusion Models Video Generation. Lil‚ÄôLog. https://lilianweng.github.io/posts/2024-04-12-diffusion-video/.\nOr\n@article{weng2024video, title = \"Diffusion Models Video Generation.\", author = \"Weng, Lilian\", journal = \"lilianweng.github.io\", year = \"2024\", month = \"Apr\", url = \"https://lilianweng.github.io/posts/2024-04-12-diffusion-video/\" } References [1] Cicek et al. 2016. ‚Äú3D U-Net: Learning Dense Volumetric Segmentation from Sparse Annotation.‚Äù\n[2] Ho \u0026 Salimans, et al. ‚ÄúVideo Diffusion Models.‚Äù 2022 | webpage\n[3] Bar-Tal et al. 2024 ‚ÄúLumiere: A Space-Time Diffusion Model for Video Generation.‚Äù\n[4] Brooks et al. ‚ÄúVideo generation models as world simulators.‚Äù OpenAI Blog, 2024.\n[5] Zhang et al. 2023 ‚ÄúControlVideo: Training-free Controllable Text-to-Video Generation.‚Äù\n[6] Khachatryan et al. 2023 ‚ÄúText2Video-Zero: Text-to-image diffusion models are zero-shot video generators.‚Äù\n[7] Ho, et al. 2022 ‚ÄúImagen Video: High Definition Video Generation with Diffusion Models.‚Äù\n[8] Singer et al. ‚ÄúMake-A-Video: Text-to-Video Generation without Text-Video Data.‚Äù 2022.\n[9] Wu et al. ‚ÄúTune-A-Video: One-Shot Tuning of Image Diffusion Models for Text-to-Video Generation.‚Äù ICCV 2023.\n[10] Blattmann et al. 2023 ‚ÄúAlign your Latents: High-Resolution Video Synthesis with Latent Diffusion Models.‚Äù\n[11] Blattmann et al. 2023 ‚ÄúStable Video Diffusion: Scaling Latent Video Diffusion Models to Large Datasets.‚Äù\n[12] Esser et al. 2023 ‚ÄúStructure and Content-Guided Video Synthesis with Diffusion Models.‚Äù\n[13] Bar-Tal et al. 2024 ‚ÄúLumiere: A Space-Time Diffusion Model for Video Generation.‚Äù\n",
  "wordCount" : "4130",
  "inLanguage": "en",
  "datePublished": "2024-04-12T00:00:00Z",
  "dateModified": "2024-04-12T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lilian Weng"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lilianweng.github.io/posts/2024-04-12-diffusion-video/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Lil'Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lilianweng.github.io/favicon_wine.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lilianweng.github.io/" accesskey="h" title="Lil&#39;Log (Alt + H)">Lil&#39;Log</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://lilianweng.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://lilianweng.github.io/faq" title="FAQ">
                    <span>FAQ</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Diffusion Models for Video Generation
    </h1>
    <div class="post-meta">Date: April 12, 2024  |  Estimated Reading Time: 20 min  |  Author: Lilian Weng

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#video-generation-modeling-from-scratch" aria-label="Video Generation Modeling from Scratch">Video Generation Modeling from Scratch</a><ul>
                        
                <li>
                    <a href="#parameterization--sampling-basics" aria-label="Parameterization &amp; Sampling Basics">Parameterization &amp; Sampling Basics</a></li>
                <li>
                    <a href="#model-architecture-3d-u-net--dit" aria-label="Model Architecture: 3D U-Net &amp; DiT">Model Architecture: 3D U-Net &amp; DiT</a></li></ul>
                </li>
                <li>
                    <a href="#adapting-image-models-to-generate-videos" aria-label="Adapting Image Models to Generate Videos">Adapting Image Models to Generate Videos</a><ul>
                        
                <li>
                    <a href="#fine-tuning-on-video-data" aria-label="Fine-tuning on Video Data">Fine-tuning on Video Data</a></li>
                <li>
                    <a href="#training-free-adaptation" aria-label="Training-Free Adaptation">Training-Free Adaptation</a></li></ul>
                </li>
                <li>
                    <a href="#citation" aria-label="Citation">Citation</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">Diffusion models</a> have demonstrated strong results on image synthesis in past years. Now the research community has started working on a harder task&mdash;using it for video generation. The task itself is a superset of the image case, since an image is a video of 1 frame, and it is much more challenging because:</p>
<ol>
<li>It has extra requirements on temporal consistency across frames in time, which naturally demands more world knowledge to be encoded into the model.</li>
<li>In comparison to text or images, it is more difficult to collect large amounts of high-quality, high-dimensional video data, let along text-video pairs.</li>
</ol>
<blockquote>
<p><br/><b>
ü•ë Required Pre-read: Please make sure you have read the previous blog on <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">&ldquo;What are Diffusion Models?&rdquo;</a> for image generation before continue here.
</b><br/><br/></p>
</blockquote>
<h1 id="video-generation-modeling-from-scratch">Video Generation Modeling from Scratch<a hidden class="anchor" aria-hidden="true" href="#video-generation-modeling-from-scratch">#</a></h1>
<p>First let&rsquo;s review approaches for designing and training diffusion video models from scratch, meaning that we do not rely on pre-trained image generators.</p>
<h2 id="parameterization--sampling-basics">Parameterization &amp; Sampling Basics<a hidden class="anchor" aria-hidden="true" href="#parameterization--sampling-basics">#</a></h2>
<p>Here we use a slightly different variable definition from the <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">previous post</a>, but the math stays the same. Let $\mathbf{x} \sim q_\text{real}$ be a data point sampled from the real data distribution. Now we are adding Gaussian noise in small amount in time, creating a sequence of noisy variations of $\mathbf{x}$, denoted as $\{\mathbf{z}_t \mid t =1 \dots, T\}$, with increasing amount of noise as $t$ increases and the last $q(\mathbf{z}_T) \sim \mathcal{N}(\mathbf{0}, \mathbf{I})$. The noise-adding forward process is a Gaussian process. Let $\alpha_t, \sigma_t$ define a differentiable noise schedule of the Gaussian process:</p>
<div>
$$
q(\mathbf{z}_t \vert \mathbf{x}) = \mathcal{N}(\mathbf{z}_t; \alpha_t \mathbf{x}, \sigma^2_t\mathbf{I})
$$
</div>
<p>To represent $q(\mathbf{z}_t \vert \mathbf{z}_s)$ for $0 \leq s &lt; t \leq T$, we have:</p>
<div>
$$
\begin{aligned}
\mathbf{z}_t &= \alpha_t \mathbf{x} + \sigma_t\boldsymbol{\epsilon}_t \\
\mathbf{z}_s &= \alpha_s \mathbf{x} + \sigma_s\boldsymbol{\epsilon}_s \\
\mathbf{z}_t &= \alpha_t \Big(\frac{\mathbf{z}_s - \sigma_s\boldsymbol{\epsilon}_s}{\alpha_s}\Big) + \sigma_t\boldsymbol{\epsilon}_t \\
\mathbf{z}_t &= \frac{\alpha_t}{\alpha_s}\mathbf{z}_s + \sigma_t\boldsymbol{\epsilon}_t - \frac{\alpha_t\sigma_s}{\alpha_s} \boldsymbol{\epsilon}_s \\
\text{Thus }q(\mathbf{z}_t \vert \mathbf{z}_s) &= \mathcal{N}\Big(\mathbf{z}_t; \frac{\alpha_t}{\alpha_s}\mathbf{z}_s, \big(1 - \frac{\alpha^2_t\sigma^2_s}{\sigma^2_t\alpha^2_s}\big)\sigma^2_t \mathbf{I}\Big)
\end{aligned}
$$
</div>
<p>Let the log signal-to-noise-ratio be $\lambda_t = \log[\alpha^2_t / \sigma^2_t]$, we can represent the DDIM (<a href="https://arxiv.org/abs/2010.02502">Song et al. 2020</a>) update as:</p>
<div>
$$
q(\mathbf{z}_t \vert \mathbf{z}_s) = \mathcal{N}\Big(\mathbf{z}_t; \frac{\alpha_t}{\alpha_s}\mathbf{z}_s, \sigma^2_{t\vert s} \mathbf{I}\Big) \quad
\text{where }\sigma^2_{t\vert s} = (1 - e^{\lambda_t - \lambda_s})\sigma^2_t
$$
</div>
<p>There is a special $\mathbf{v}$-prediction ($\mathbf{v} = \alpha_t \boldsymbol{\epsilon} - \sigma_t \mathbf{x}$) parameterization, proposed by <a href="https://arxiv.org/abs/2202.00512">Salimans &amp; Ho (2022)</a>. It has been shown to be helpful for avoiding color shift in video generation compared to $\boldsymbol{\epsilon}$-parameterization.</p>
<p>The $\mathbf{v}$-parameterization is derived with a trick in the angular coordinate. First, we define $\phi_t = \arctan(\sigma_t / \alpha_t)$ and thus we have $\alpha_\phi = \cos\phi, \sigma_t = \sin\phi, \mathbf{z}_\phi = \cos\phi \mathbf{x} + \sin\phi\boldsymbol{\epsilon}$. The velocity of $\mathbf{z}_\phi$ can be written as:</p>
<div>
$$
\mathbf{v}_\phi = \nabla_\phi \mathbf{z}_\phi = \frac{d\cos\phi}{d\phi} \mathbf{x} + \frac{d\sin\phi}{d\phi}\boldsymbol{\epsilon} = \cos\phi\boldsymbol{\epsilon} -\sin\phi\mathbf{x}
$$
</div>
<p>Then we can infer,</p>
<div>
$$
\begin{aligned}
\sin\phi\mathbf{x} 
&= \cos\phi\boldsymbol{\epsilon}  - \mathbf{v}_\phi \\
&= \frac{\cos\phi}{\sin\phi}\big(\mathbf{z}_\phi - \cos\phi\mathbf{x}\big) - \mathbf{v}_\phi \\
\sin^2\phi\mathbf{x} 
&= \cos\phi\mathbf{z}_\phi - \cos^2\phi\mathbf{x} - \sin\phi \mathbf{v}_\phi \\
\mathbf{x} &= \cos\phi\mathbf{z}_\phi - \sin\phi\mathbf{v}_\phi \\
\text{Similarly }
\boldsymbol{\epsilon} &= \sin\phi\mathbf{z}_\phi + \cos\phi \mathbf{v}_\phi
\end{aligned}
$$
</div>
<p>The DDIM update rule is updated accordingly,</p>
<div>
$$
\begin{aligned}
\mathbf{z}_{\phi_s} 
&= \cos\phi_s\hat{\mathbf{x}}_\theta(\mathbf{z}_{\phi_t}) + \sin\phi_s\hat{\epsilon}_\theta(\mathbf{z}_{\phi_t}) \quad\quad{\small \text{; }\hat{\mathbf{x}}_\theta(.), \hat{\epsilon}_\theta(.)\text{ are two models to predict }\mathbf{x}, \boldsymbol{\epsilon}\text{ based on }\mathbf{z}_{\phi_t}}\\
&= \cos\phi_s \big( \cos\phi_t \mathbf{z}_{\phi_t} - \sin\phi_t \hat{\mathbf{v}}_\theta(\mathbf{z}_{\phi_t} ) \big) +
\sin\phi_s \big( \sin\phi_t \mathbf{z}_{\phi_t} + \cos\phi_t \hat{\mathbf{v}}_\theta(\mathbf{z}_{\phi_t} ) \big) \\
&= {\color{red} \big( \cos\phi_s\cos\phi_t + \sin\phi_s\sin\phi_t \big)} \mathbf{z}_{\phi_t} + 
{\color{green} \big( \sin\phi_s \cos\phi_t - \cos\phi_s \sin\phi_t \big)} \hat{\mathbf{v}}_\theta(\mathbf{z}_{\phi_t} ) \\
&= {\color{red} cos(\phi_s - \phi_t)} \mathbf{z}_{\phi_t} +
{\color{green} \sin(\phi_s - \phi_t)} \hat{\mathbf{v}}_\theta(\mathbf{z}_{\phi_t}) \quad\quad{\small \text{; trigonometric identity functions.}}
\end{aligned}
$$
</div>
<figure>
	<img src="v-param.png" style="width: 30%;"  />
	<figcaption>Visualizing how the diffusion update step works in the angular coordinate, where DDIM evolves $\mathbf{z}_{\phi_s}$ by moving it along the $-\hat{\mathbf{v}}_{\phi_t}$ direction. (Image source: <a href="https://arxiv.org/abs/2202.00512" target="_blank">Salimans & Ho, 2022</a>)</figcaption>
</figure>
<p>The $\mathbf{v}$-parameterization for the model is to predict $\mathbf{v}_\phi = \cos\phi\boldsymbol{\epsilon} -\sin\phi\mathbf{x} = \alpha_t\boldsymbol{\epsilon} - \sigma_t\mathbf{x}$.</p>
<p>In the case of video generation, we need the diffusion model to run multiple steps of upsampling for extending video length or increasing the frame rate. This requires the capability of sampling a second video $\mathbf{x}^b$ conditioned on the first $\mathbf{x}^a$, $\mathbf{x}^b \sim p_\theta(\mathbf{x}^b \vert \mathbf{x}^a)$, where $\mathbf{x}^b$ might be an autoregressive extension of $\mathbf{x}^a$ or be the missing frames in-between for a video $\mathbf{x}^a$ at a low frame rate.</p>
<p>The sampling of $\mathbf{x}_b$ needs to condition on $\mathbf{x}_a$ besides its own corresponding noisy variable. <strong>Video Diffusion Models</strong> (<strong>VDM</strong>; <a href="https://arxiv.org/abs/2204.03458">Ho &amp; Salimans, et al. 2022</a>) proposed the <em>reconstruction guidance</em> method using an adjusted denoising model such that the sampling of $\mathbf{x}^b$ can be properly conditioned on $\mathbf{x}^a$:</p>
<div>
$$
\begin{aligned}
\mathbb{E}_q [\mathbf{x}_b \vert \mathbf{z}_t, \mathbf{x}^a] &= \mathbb{E}_q [\mathbf{x}^b \vert \mathbf{z}_t] + \frac{\sigma_t^2}{\alpha_t} \nabla_{\mathbf{z}^b_t} \log q(\mathbf{x}^a \vert \mathbf{z}_t) \\
q(\mathbf{x}^a \vert \mathbf{z}_t) &\approx \mathcal{N}\big[\hat{\mathbf{x}}^a_\theta (\mathbf{z}_t), \frac{\sigma_t^2}{\alpha_t^2}\mathbf{I}\big] & {\small \text{; the closed form is unknown.}}\\
\tilde{\mathbf{x}}^b_\theta (\mathbf{z}_t) &= \hat{\mathbf{x}}^b_\theta (\mathbf{z}_t) - \frac{w_r \alpha_t}{2} \nabla_{\mathbf{z}_t^b} \| \mathbf{x}^a - \hat{\mathbf{x}}^a_\theta (\mathbf{z}_t) \|^2_2 & {\small \text{; an adjusted denoising model for }\mathbf{x}^b}
\end{aligned}
$$
</div>
<p>where $\hat{\mathbf{x}}^a_\theta (\mathbf{z}_t), \hat{\mathbf{x}}^b_\theta (\mathbf{z}_t)$ are reconstructions of $\mathbf{x}^a, \mathbf{x}^b$ provided by the denoising model. And $w_r$ is a weighting factor and a large one $w_r &gt;1$ is found to improve sample quality. Note that it is also possible to simultaneously condition on low resolution videos to extend samples to be at the high resolution using the same reconstruction guidance method.</p>
<h2 id="model-architecture-3d-u-net--dit">Model Architecture: 3D U-Net &amp; DiT<a hidden class="anchor" aria-hidden="true" href="#model-architecture-3d-u-net--dit">#</a></h2>
<p>Similar to text-to-image diffusion models, U-net and Transformer are still two <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#model-architecture">common architecture choices</a>. There are a series of diffusion video modeling papers from Google based on the U-net architecture and a recent Sora model from OpenAI leveraged the Transformer architecture.</p>
<p><strong>VDM</strong> (<a href="https://arxiv.org/abs/2204.03458">Ho &amp; Salimans, et al. 2022</a>) adopts the standard diffusion model setup but with an altered architecture suitable for video modeling. It extends the <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#model-architecture">2D U-net</a> to work for 3D data (<a href="https://arxiv.org/abs/1606.06650">Cicek et al. 2016</a>), where each feature map represents a 4D tensor of frames x height x width x channels. This 3D U-net is factorized over space and time, meaning that each layer only operates on the space or time dimension, but not both:</p>
<ul>
<li>Processing <em>Space</em>:
<ul>
<li>Each old 2D convolution layer as in the 2D U-net is extended to be space-only 3D convolution; precisely, 3x3 convolutions become 1x3x3 convolutions.</li>
<li>Each spatial attention block remains as attention over space, where the first axis (<code>frames</code>) is treated as batch dimension.</li>
</ul>
</li>
<li>Processing <em>Time</em>:
<ul>
<li>A temporal attention block is added after each spatial attention block. It performs attention over the first axis (<code>frames</code>) and treats spatial axes as the batch dimension. The <a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/#relative-position-encoding">relative position</a> embedding is used for tracking the order of frames. The temporal attention block is important for the model to capture good temporal coherence.</li>
</ul>
</li>
</ul>
<figure>
	<img src="3D-U-net.png" style="width: 100%;"  />
	<figcaption>The 3D U-net architecture. The noisy video $\mathbf{z}_t$ , conditioning information $\boldsymbol{c}$ and the log signal-to-noise ratio (log-SNR) $\lambda_t$ are inputs to the network. The channel multipliers $M_1, \dots, M_K$ represent the channel counts across layers. (Image source: <a href="https://arxiv.org/abs/2204.03458" target="_blank">Salimans & Ho, 2022</a>)</figcaption>
</figure>
<p><strong>Imagen Video</strong> (<a href="https://arxiv.org/abs/2210.02303">Ho, et al. 2022</a>) is constructed on a cascade of diffusion models to enhance the video generation quality and upgrades to output 1280x768 videos at 24 fps. The Imagen Video architecture consists of the following components, counting 7 diffusion models in total.</p>
<ul>
<li>A frozen <a href="https://lilianweng.github.io/posts/2019-01-31-lm/#t5">T5</a> text encoder to provide text embedding as the conditioning input.</li>
<li>A base video diffusion model.</li>
<li>A cascade of interleaved <em>spatial and temporal super-resolution</em> diffusion models, including 3 TSR (Temporal Super-Resolution) and 3 SSR (Spatial Super-Resolution) components.</li>
</ul>
<figure>
	<img src="imagen-video.png" style="width: 100%;"  />
	<figcaption>The cascaded sampling pipeline in Imagen Video. In practice, the text embeddings are injected into all components, not just the base model. (Image source: <a href="https://arxiv.org/abs/2210.02303" target="_blank">Ho et al. 2022</a>)</figcaption>
</figure>
<p>The base denoising models performs spatial operations over all the frames with shared parameters simultaneously and then the temporal layer mixes activations across frames to better capture temporal coherence, which is found to work better than frame-autoregressive approaches.</p>
<figure>
	<img src="imagen-video-Unet-block.png" style="width: 100%;"  />
	<figcaption>The architecture of one space-time separable block in the Imagen Video diffusion model. (Image source: <a href="https://arxiv.org/abs/2210.02303" target="_blank">Ho et al. 2022</a>)</figcaption>
</figure>
<p>Both SSR and TSR models condition on the upsampled inputs concatenated with noisy data $\mathbf{z}_t$ channel-wise. SSR upsamples by <a href="https://chao-ji.github.io/jekyll/update/2018/07/19/BilinearResize.html">bilinear resizing</a>, while TSR upsamples by repeating the frames or filling in blank frames.</p>
<p>Imagen Video also applies <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#prog-distll">progressive distillation</a> to speed up sampling and each distillation iteration can reduce the required sampling steps by half. Their experiments were able to distill all 7 video diffusion models down to just 8 sampling steps per model without any noticeable loss in perceptual quality.</p>
<!--
Use classifier-free guidance. When using large guidance weight, a standard approach to avoid train-test mismatch is to clip the pixel value to be `np.clip(x, -1, 1)`, but it can lead to over-saturation. Dynamic clipping relies on a dynamically chosen threshold `s` to do clipping, `np.clip(x, -s, s)/s`. However, only using dynamic clipping is not enough, so they also oscillate  the value of $w$ during training ("oscillating guidance"): use high w initially and then oscillate between `[1, 15]`. Oscillate guidance is only applied to the base and first 2 SR models.
-->
<p>To achieve better scaling efforts, <strong>Sora</strong> (<a href="https://openai.com/research/video-generation-models-as-world-simulators">Brooks et al. 2024</a>) leverages <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#model-architecture">DiT (Diffusion Transformer)</a> architecture that operates on spacetime patches of video and image latent codes. Visual input is represented as a sequence of spacetime patches which act as Transformer input tokens.</p>
<figure>
	<img src="sora.png" style="width: 100%;"  />
	<figcaption>Sora is a diffusion transformer model.<br/>(Image source: <a href="https://openai.com/research/video-generation-models-as-world-simulators" target="_blank">Brooks et al. 2024</a>)</figcaption>
</figure>
<h1 id="adapting-image-models-to-generate-videos">Adapting Image Models to Generate Videos<a hidden class="anchor" aria-hidden="true" href="#adapting-image-models-to-generate-videos">#</a></h1>
<p>Another prominent approach for diffusion video modeling is to &ldquo;inflate&rdquo; a pre-trained image-to-text diffusion model by inserting temporal layers and then we can choose to <em>only</em> fine-tune new layers on video data, or avoid extra training at all. The prior knowledge of text-image pairs is inherited by the new model and thus it can help alleviate the requirement on text-video pair data.</p>
<h2 id="fine-tuning-on-video-data">Fine-tuning on Video Data<a hidden class="anchor" aria-hidden="true" href="#fine-tuning-on-video-data">#</a></h2>
<p><strong>Make-A-Video</strong> (<a href="https://arxiv.org/abs/2209.14792">Singer et al. 2022</a>) extends a pre-trained diffusion image model with a temporal dimension, consisting of three key components:</p>
<ol>
<li>A base text-to-image model trained on text-image pair data.</li>
<li>Spatiotemporal convolution and attention layers to extend the network to cover temporal dimension.</li>
<li>A frame interpolation network for high frame rate generation</li>
</ol>
<figure>
	<img src="make-a-video.png" style="width: 100%;"  />
	<figcaption>The illustration of Make-A-Video pipeline.<br/>(Image source: <a href="https://arxiv.org/abs/2209.14792" target="_blank">Singer et al. 2022</a>)</figcaption>
</figure>
<p>The final video inference scheme can be formulated as:</p>
<div>
$$
\hat{\mathbf{y}}_t = \text{SR}_h \circ \text{SR}^t_l \circ \uparrow_F \circ D^t \circ P \circ (\hat{\mathbf{x}}, \text{CLIP}_\text{text}(\mathbf{x}))
$$
</div>
<p>where:</p>
<ul>
<li>$\mathbf{x}$ is the input text.</li>
<li>$\hat{\mathbf{x}}$ is the BPE-encoded text.</li>
<li>$\text{CLIP}_\text{text}(.)$ is the CLIP text encoder, $\mathbf{x}_e = \text{CLIP}_\text{text}(\mathbf{x})$.</li>
<li>$P(.)$ is the prior, generating image embedding $\mathbf{y}_e$ given text embedding $\mathbf{x}_e$ and BPE encoded text $\hat{\mathbf{x}}$ : $\mathbf{y}_e = P(\mathbf{x}_e, \hat{\mathbf{x}})$. This part is trained on text-image pair data and not fine-tuned on video data.</li>
<li>$D^t(.)$ is the spatiotemporal decoder that generates a series of 16 frames, where each frame is a low-resolution 64x64 RGB image $\hat{\mathbf{y}}_l$.</li>
<li>$\uparrow_F(.)$ is the frame interpolation network, increasing the effective frame rate by interpolating between generated frames. This is a fine-tuned model for the task of predicting masked frames for video upsampling.</li>
<li>$\text{SR}_h(.), \text{SR}^t_l(.)$ are the spatial and spatiotemporal super-resolution models, increasing the image resolution to 256x256 and 768x768, respectively.</li>
<li>$\hat{\mathbf{y}}_t$ is the final generated video.</li>
</ul>
<p>Spatiotemporal SR layers contain pseudo-3D convo layers and pseudo-3D attention layers:</p>
<ul>
<li>Pseudo-3D convo layer : Each spatial 2D convo layer (initialized from the pre-training image model) is followed by a temporal 1D layer (initialized as the identity function). Conceptually, the convo 2D layer first generates multiple frames and then frames are reshaped to be a video clip.</li>
<li>Pseudo-3D attention layer: Following each (pre-trained) spatial attention layer, a temporal attention layer is stacked and used to approximate a full spatiotemporal attention layer.</li>
</ul>
<figure>
	<img src="make-a-video-layers.png" style="width: 100%;"  />
	<figcaption>How pseudo-3D convolution (left) and attention (right) layers work.<br/>(Image source: <a href="https://arxiv.org/abs/2209.14792" target="_blank">Singer et al. 2022</a>)</figcaption>
</figure>
<p>They can be represented as:</p>
<div>
$$
\begin{aligned}
\text{Conv}_\text{P3D} &= \text{Conv}_\text{1D}(\text{Conv}_\text{2D}(\mathbf{h}) \circ T) \circ T \\
\text{Attn}_\text{P3D} &= \text{flatten}^{-1}(\text{Attn}_\text{1D}(\text{Attn}_\text{2D}(\text{flatten}(\mathbf{h})) \circ T) \circ T)
\end{aligned}
$$
</div>
<p>where an input tensor $\mathbf{h} \in \mathbb{R}^{B\times C \times F \times H \times W}$  (corresponding to batch size, channels, frames, height and weight); and $\circ T$ swaps between temporal and spatial dimensions; $\text{flatten}(.)$ is a matrix operator to convert $\mathbf{h}$ to be $\mathbf{h}&rsquo; \in \mathbb{R}^{B \times C \times F \times HW}$ and $\text{flatten}^{-1}(.)$ reverses that process.</p>
<p>During training, different components of Make-A-Video pipeline are trained independently.</p>
<ol>
<li>Decoder $D^t$, prior $P$ and two super-resolution components $\text{SR}_h, \text{SR}^t_l$ are first trained on images alone, without paired text.</li>
<li>Next the new temporal layers are added, initialized as identity function, and then fine-tuned on unlabeled video data.</li>
</ol>
<p><strong>Tune-A-Video</strong> (<a href="https://openaccess.thecvf.com/content/ICCV2023/html/Wu_Tune-A-Video_One-Shot_Tuning_of_Image_Diffusion_Models_for_Text-to-Video_Generation_ICCV_2023_paper.html">Wu et al. 2023</a>) inflates a pre-trained image diffusion model to enable one-shot video tuning: Given a video containing $m$ frames, $\mathcal{V} = \{v_i \mid i = 1, \dots, m\}$, paired with a descriptive prompt $\tau$, the task is to generate a new video $\mathcal{V}^*$ based on a slightly edited &amp; related text prompt $\tau^*$. For example, $\tau$ = <code>&quot;A man is skiing&quot;</code> can be extended to $\tau^*$=<code>&quot;Spiderman is skiing on the beach&quot;</code>. Tune-A-Video is meant to be used for object editing, background change, and style transfer.</p>
<p>Besides inflating the 2D convo layer, the U-Net architecture of Tune-A-Video incorporates the ST-Attention (spatiotemporal attention) block to capture temporal consistency by querying relevant positions in previous frames. Given latent features of frame $v_i$, previous frames $v_{i-1}$ and the first frame $v_1$ are projected to query $\mathbf{Q}$, key $\mathbf{K}$ and value $\mathbf{V}$, the ST-attention is defined as:</p>
<div>
$$
\begin{aligned}
&\mathbf{Q} = \mathbf{W}^Q \mathbf{z}_{v_i}, \quad \mathbf{K} = \mathbf{W}^K [\mathbf{z}_{v_1}, \mathbf{z}_{v_{i-1}}], \quad \mathbf{V} = \mathbf{W}^V [\mathbf{z}_{v_1}, \mathbf{z}_{v_{i-1}}] \\
&\mathbf{O} = \text{softmax}\Big(\frac{\mathbf{Q} \mathbf{K}^\top}{\sqrt{d}}\Big) \cdot \mathbf{V}
\end{aligned}
$$
</div>
<figure>
	<img src="tune-a-video.png" style="width: 100%;"  />
	<figcaption>The Tune-A-Video architecture overview. It first runs a light-weighted fine-tuning stage on a single video before the sampling stage. Note that the entire temporal self-attention (T-Attn) layers get fine-tuned because they are newly added, but only query projections in ST-Attn and Cross-Attn are updated during fine-tuning to preserve prior text-to-image knowledge. ST-Attn improves spatial-temporal consistency, Cross-Attn refines text-video alignment. (Image source: <a href="https://openaccess.thecvf.com/content/ICCV2023/html/Wu_Tune-A-Video_One-Shot_Tuning_of_Image_Diffusion_Models_for_Text-to-Video_Generation_ICCV_2023_paper.html" target="_blank">Wu et al. 2023</a>)</figcaption>
</figure>
<p><strong>Gen-1</strong> model  (<a href="https://arxiv.org/abs/2302.03011">Esser et al. 2023</a>) by Runway targets the task of editing a given video according to text inputs. It decomposes the consideration of <em>structure</em> and <em>content</em> of a video $p(\mathbf{x} \mid s, c)$ for generation conditioning. However, to do a clear decomposition of these two aspects is not easy.</p>
<ul>
<li><em>Content</em> $c$ refers to appearance and semantics of the video, that is sampled from the text for conditional editing. CLIP embedding of the frame is a good representation of content, and stays largely orthogonal to structure traits.</li>
<li><em>Structure</em> $s$ depicts greometry and dynamics, including shapes, locations, temporal changes of objects, and $s$ is sampled from the input video. Depth estimation or other task-specific side information (e.g. human body pose or face landmarks for human video synthesis) can be used.</li>
</ul>
<p>The architecture changes in Gen-1 are quite standard, i.e. adding 1D temporal convo layer after each 2D spatial convo layer in its residual blocks and adding 1D temporal attention block after each 2D spatial attention block in its attention blocks. During training, the structure variable $s$ is concatenated with the diffusion latent variable $\mathbf{z}$, where the content variable $c$ is provided in the cross-attention layer. At inference time, the clip embedding is converted via a prior to convert CLIP text embedding to be CLIP image embedding.</p>
<figure>
	<img src="gen-1.png" style="width: 100%;"  />
	<figcaption>The overview of the Gen-1 model training pipeline.<br/>(Image source: <a href="https://arxiv.org/abs/2302.03011" target="_blank">Esser et al. 2023</a>)</figcaption>
</figure>
<p><strong>Video LDM</strong> (<a href="https://arxiv.org/abs/2304.08818">Blattmann et al. 2023</a>) trains a <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#latent-variable-space">LDM</a> (Latent diffusion models) image generator first. Then the model is fine-tuned to produce videos with a temporal dimension added. The fine-tuning only applies to these newly added temporal layers on encoded image sequences. The temporal layers $\{l^i_\phi \mid i = \ 1, \dots, L\}$ in the Video LDM (See Fig. 10) are interleaved with existing spatial layers $l^i_\theta$ which stays <em>frozen</em> during fine-tuning. That&rsquo;s being said, we only fine-tune the new parameters $\phi$ but not the pre-trained image backbone model parameters $\theta$. The pipeline of Video LDM first generates key frames at low fps and then processes through 2 steps of latent frame interpolations to increase fps.</p>
<p>The input sequence of length $T$ is interpreted as a batch of images (i.e. $B \cdot T$) for the base image model $\theta$ and then gets reshaped into video format for $l^i_\phi$ temporal layers. There is a skip connection leads to a combination of temporal layer output $\mathbf{z}&rsquo;$ and the spatial output $\mathbf{z}$ via a learned merging parameter $\alpha$. There are two types of temporal mixing layers implemented in practice: (1) temporal attention and (2) residual blocks based on 3D convolutions.</p>
<figure>
	<img src="video-LDM.png" style="width: 100%;"  />
	<figcaption>A pre-training LDM for image synthesis is extended to be a video generator. $B, T, C, H, W$ are batch size, sequence length, channels, height and width, respectively. $\mathbf{c}_S$ is an optional conditioning/context frame. (Image source: <a href="https://arxiv.org/abs/2304.08818" target="_blank">Blattmann et al. 2023</a>)</figcaption>
</figure>
<p>However, there is a remaining issue with LDM&rsquo;s pretrainined autoencoder which only sees images never videos. Naively using that for video generation can cause flickering artifacts without good temporal coherence. So Video LDM adds additional temporal layers into the decoder and fine-tuned on video data with a patch-wise temporal discriminator built from 3D convolutions, while the encoder remains unchanged so that we still can reuse the pretrained LDM. During temporal decoder fine-tuning, the frozen encoder processes each frame in the video independently, and enforce temporally coherent reconstructions across frames with a video-aware discriminator.</p>
<figure>
	<img src="video-LDM-autoencoder.png" style="width: 75%;"  />
	<figcaption>The training pipeline of autoencoder in video latent diffusion models. The decoder is fine-tuned to have temporal coherency with a new across-frame discriminator while the encoder stays frozen. (Image source: <a href="https://arxiv.org/abs/2304.08818" target="_blank">Blattmann et al. 2023</a>)</figcaption>
</figure>
<p>Similar to Video LDM, the architecture design of <strong>Stable Video Diffusion</strong> (<strong>SVD</strong>; <a href="https://arxiv.org/abs/2311.15127">Blattmann et al. 2023</a>) is also based on LDM with temporal layers inserted after every spatial convolution and attention layer, but SVD fine-tunes the entire model. There are three stages for training video LDMs:</p>
<ol>
<li><em>Text-to-image pretraining</em> is important and helps improve both quality and prompt following.</li>
<li><em>Video pretraining</em> is beneficial to be separated and should ideally occur on a larger scale, curated dataset.</li>
<li><em>High-quality video finetuning</em> works with a smaller, pre-captioned video of high visual fidelity.</li>
</ol>
<p>SVD specially emphasizes the critical role of <em>dataset curation</em> in model performance. They applied a cut detection pipeline to get more cuts per video and then applied three different captioner models: (1) CoCa for mid-frame, (2) V-BLIP for a video caption, and (3) LLM based captioning based on previous two captions. Then they were able to continue to improve video datasets, by removing clips with less motion (filtered by low optical flow scores calculated at 2 fps), excessive text presence (apply optical character recognition to identify videos with lots of text), or generally low aesthetic value (annotate the first, middle, and last frames of each clip with CLIP embeddings and calculate aesthetics scores &amp; text-image similarities). The experiments showed that a filtered, higher quality dataset leads to better model quality, even when this dataset is much smaller.</p>
<p>The key challenge of generating distant key frames first and then adding interpolation with temporal super-resolution is how to maintain high-quality temporal consistency. <strong>Lumiere</strong> (<a href="https://arxiv.org/abs/2401.12945">Bar-Tal et al. 2024</a>) instead adopts a <strong>space-time U-Net (STUNet)</strong> architecture that generates the entire temporal duration of the video <em>at once</em> through a single pass, removing the dependency on TSR (temporal super-resolution) components. STUNet downsamples the video in both time and space dimensions and thus expensive computation happens in a compact time-space latent space.</p>
<figure>
	<img src="lumiere.png" style="width: 75%;"  />
	<figcaption>Lumiere removes TSR (temporal super-resolution) models. The inflated SSR network can operate only on short segments of the video due to memory constraints and thus SSR models operate on a set of shorter but overlapped video snippets. (Image source: <a href="https://arxiv.org/abs/2401.12945" target="_blank">Bar-Tal et al. 2024</a>)</figcaption>
</figure>
<p>STUNet inflates a <em>pretrained</em> text-to-image U-net to be able to downsample and upsample videos at both time and space dimensions. Convo-based blocks consist of pre-trained text-to-image layers, followed by a factorized space-time convolution. And attention-based blocks at the coarsest U-Net level contains the pre-trained text-to-image, followed by temporal attention. Further training <em>only</em> happens with the newly added layers.</p>
<figure>
	<img src="lumiere-STUnet.png" style="width: 100%;"  />
	<figcaption>The architecture of (a) Space-Time U-Net (STUNet), (b) the convolution-based block, and (c) the attention-based block. (Image source: <a href="https://arxiv.org/abs/2401.12945" target="_blank">Bar-Tal et al. 2024</a>)</figcaption>
</figure>
<!-- User study results using the 2AFC protocol (two-alternative forced choice), where users are pick a better one out of a random pair of images generated by two different models.
![[Pasted image 20240403102834.png|400]] -->
<h2 id="training-free-adaptation">Training-Free Adaptation<a hidden class="anchor" aria-hidden="true" href="#training-free-adaptation">#</a></h2>
<p>Somehow surprisingly, it is possible to adapt a pre-trained text-to-image model to output videos without any training ü§Ø.</p>
<p>If we naively sample a sequence of latent codes at random and then construct a video of decoded corresponding images, there is no guarantee in the consistency in objects and semantics in time. <strong>Text2Video-Zero</strong> (<a href="https://arxiv.org/abs/2303.13439">Khachatryan et al. 2023</a>) enables zero-shot, training-free video generation by enhancing a pre-trained image diffusion model with two key mechanisms for temporal consistency:</p>
<ol>
<li>Sampling the sequence of latent codes with <em>motion dynamics</em> to keep the global scene and the background time consistent;</li>
<li>Reprogramming frame-level self-attention using a <em>new cross-frame attention</em> of each frame on the first frame, to preserve the context, appearance, and identity of the foreground object.</li>
</ol>
<figure>
	<img src="text2video-zero.png" style="width: 100%;"  />
	<figcaption>An overview of the Text2Video-Zero pipeline. (Image source: <a href="https://arxiv.org/abs/2303.13439" target="_blank">Khachatryan et al. 2023</a>)</figcaption>
</figure>
<p>The process of sampling a sequence of latent variables, $\mathbf{x}^1_T, \dots, \mathbf{x}^m_T$, with motion information is described as follows:</p>
<ol>
<li>Define a direction $\boldsymbol{\delta} = (\delta_x, \delta_y) \in \mathbb{R}^2$ for controlling the global scene and camera motion; by default, we set $\boldsymbol{\delta} = (1, 1)$. Also define a hyperparameter $\lambda &gt; 0$ controlling the amount of global motion.</li>
<li>First sample the latent code of the first frame at random, $\mathbf{x}^1_T \sim \mathcal{N}(0, I)$;</li>
<li>Perform $\Delta t \geq 0$ DDIM backward update steps using the pre-trained image diffusion model, e.g. Stable Diffusion (SD) model in the paper, and obtain the corresponding latent code $\mathbf{x}^1_{T&rsquo;}$ where $T&rsquo; = T - \Delta t$.</li>
<li>For each frame in the latent code sequence, we apply corresponding motion translation with a warping operation defined by $\boldsymbol{\delta}^k = \lambda(k-1)\boldsymbol{\delta}$ to obtain $\tilde{\mathbf{x}}^k_{T&rsquo;}$.</li>
<li>Finally apply DDIM forward steps to all $\tilde{\mathbf{x}}^{2:m}_{T&rsquo;}$ to obtain $\mathbf{x}^{2:m}_T$.</li>
</ol>
<div>
$$
\begin{aligned}
\mathbf{x}^1_{T'} &= \text{DDIM-backward}(\mathbf{x}^1_T, \Delta t)\text{ where }T' = T - \Delta t \\
W_k &\gets \text{a warping operation of }\boldsymbol{\delta}^k = \lambda(k-1)\boldsymbol{\delta} \\
\tilde{\mathbf{x}}^k_{T'} &= W_k(\mathbf{x}^1_{T'})\\
\mathbf{x}^k_T &= \text{DDIM-forward}(\tilde{\mathbf{x}}^k_{T'}, \Delta t)\text{ for }k=2, \dots, m
\end{aligned}
$$
</div>
<p>Besides, Text2Video-Zero replaces the self-attention layer in a pre-trained SD model with a new cross-frame attention mechanism with reference to the <em>first</em> frame. The motivation is to preserve the information about the foreground object‚Äôs appearance, shape, and identity throughout the generated video.</p>
<div> 
$$
\text{Cross-Frame-Attn}(\mathbf{Q}^k, \mathbf{K}^{1:m}, \mathbf{V}^{1:m}) = \text{Softmax}\Big( \frac{\mathbf{Q}^k (\mathbf{K}^1)^\top}{\sqrt{c}} \Big) \mathbf{V}^1
$$
</div>
<p>Optionally, the background mask can be used to further smoothen and improve background consistency. Let&rsquo;s say, we obtain a corresponding foreground mask $\mathbf{M}_k$ for the $k$-th frame using some existing method, and background smoothing merges the actual and the warped latent code at the diffusion step $t$, w.r.t. the background matrix:</p>
<div> 
$$
\bar{\mathbf{x}}^k_t = \mathbf{M}^k \odot \mathbf{x}^k_t + (1 ‚àí \mathbf{M}^k) \odot (\alpha\tilde{\mathbf{x}}^k_t +(1‚àí\alpha)\mathbf{x}^k_t)\quad\text{for }k=1, \dots, m
$$
</div>
<p>where $\mathbf{x}^k_t$ is the actual latent code and $\tilde{\mathbf{x}}^k_t$ is the warped latent code on the background; $\alpha$ is a hyperparameter and the papers set $\alpha=0.6$ in the experiments.</p>
<p>Text2video-zero can be combined with <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#controlnet">ControlNet</a> where the ControlNet pretrained copy branch is applied per frame on each $\mathbf{x}^k_t$ for $k = 1, \dots, m$ in each diffusion time-step $t = T , \dots, 1$ and add the ControlNet branch outputs to the skip-connections of the main U-net.</p>
<p><strong>ControlVideo</strong> (<a href="https://arxiv.org/abs/2305.13077">Zhang et al. 2023</a>) aims to generate videos conditioned on text prompt $\tau$ and a motion sequence (e.g., depth or edge maps), $\mathbf{c} = \{c^i\}_{i=0}^{N-1}$. It is adapted from <a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/#controlnet">ControlNet</a> with three new mechanisms added:</p>
<ol>
<li><em>Cross-frame attention</em>: Adds fully cross-frame interaction in self-attention modules. It introduces interactions between all the frames, by mapping the latent frames at <em>all the time steps</em> into $\mathbf{Q}, \mathbf{K}, \mathbf{V}$ matrices, different from Text2Video-zero which only configures all the frames to attend to the <em>first</em> frame.</li>
<li><em>Interleaved-frame smoother</em> is a mechanism to employ frame interpolation on alternated frames to reduce the flickering effect. At each time step $t$, the smoother interpolates the even or odd frames to smooth their corresponding three-frame clips. Note that the number of frames decreases in time after smoothing steps.</li>
<li><em>Hierarchical sampler</em> utilizes a hierarchical sampler to enable long videos with time consistency under memory constraints. A long video is split into multiple short clips and each has a key frame selected. The model pre-generates these keyframes with full cross-frame attention for long-term coherency and each corresponding short clip is synthesized sequentially conditioned on the keyframes.</li>
</ol>
<figure>
	<img src="control-video.png" style="width: 100%;"  />
	<figcaption>The overview of ControlVideo. (Image source: <a href="https://arxiv.org/abs/2305.13077" target="_blank">Zhang et al. 2023</a>)</figcaption>
</figure>
<h1 id="citation">Citation<a hidden class="anchor" aria-hidden="true" href="#citation">#</a></h1>
<p>Cited as:</p>
<blockquote>
<p>Weng, Lilian. (Apr 2024). Diffusion Models Video Generation. Lil&rsquo;Log. https://lilianweng.github.io/posts/2024-04-12-diffusion-video/.</p>
</blockquote>
<p>Or</p>
<pre tabindex="0"><code>@article{weng2024video,
  title   = &#34;Diffusion Models Video Generation.&#34;,
  author  = &#34;Weng, Lilian&#34;,
  journal = &#34;lilianweng.github.io&#34;,
  year    = &#34;2024&#34;,
  month   = &#34;Apr&#34;,
  url     = &#34;https://lilianweng.github.io/posts/2024-04-12-diffusion-video/&#34;
}
</code></pre><h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p>[1] Cicek et al. 2016. <a href="https://arxiv.org/abs/1606.06650">&ldquo;3D U-Net: Learning Dense Volumetric Segmentation from Sparse Annotation.&rdquo;</a></p>
<p>[2] Ho &amp; Salimans, et al. <a href="https://arxiv.org/abs/2204.03458">&ldquo;Video Diffusion Models.&rdquo;</a> 2022 | <a href="https://video-diffusion.github.io/">webpage</a></p>
<p>[3] Bar-Tal et al. 2024 <a href="https://arxiv.org/abs/2401.12945">&ldquo;Lumiere: A Space-Time Diffusion Model for Video Generation.&rdquo;</a></p>
<p>[4] Brooks et al. <a href="https://openai.com/research/video-generation-models-as-world-simulators">&ldquo;Video generation models as world simulators.&rdquo;</a> OpenAI Blog, 2024.</p>
<p>[5] Zhang et al. 2023 <a href="https://arxiv.org/abs/2305.13077">&ldquo;ControlVideo: Training-free Controllable Text-to-Video Generation.&rdquo;</a></p>
<p>[6] Khachatryan et al. 2023 <a href="https://arxiv.org/abs/2303.13439">&ldquo;Text2Video-Zero: Text-to-image diffusion models are zero-shot video generators.&rdquo;</a></p>
<p>[7] Ho, et al. 2022 <a href="https://arxiv.org/abs/2210.02303">&ldquo;Imagen Video: High Definition Video Generation with Diffusion Models.&rdquo;</a></p>
<p>[8] Singer et al. <a href="https://arxiv.org/abs/2209.14792">&ldquo;Make-A-Video: Text-to-Video Generation without Text-Video Data.&rdquo;</a> 2022.</p>
<p>[9] Wu et al. <a href="https://openaccess.thecvf.com/content/ICCV2023/html/Wu_Tune-A-Video_One-Shot_Tuning_of_Image_Diffusion_Models_for_Text-to-Video_Generation_ICCV_2023_paper.html">&ldquo;Tune-A-Video: One-Shot Tuning of Image Diffusion Models for Text-to-Video Generation.&rdquo;</a> ICCV 2023.</p>
<p>[10] Blattmann et al. 2023 <a href="https://arxiv.org/abs/2304.08818">&ldquo;Align your Latents: High-Resolution Video Synthesis with Latent Diffusion Models.&rdquo;</a></p>
<p>[11] Blattmann et al. 2023 <a href="https://arxiv.org/abs/2311.15127">&ldquo;Stable Video Diffusion: Scaling Latent Video Diffusion Models to Large Datasets.&rdquo;</a></p>
<p>[12] Esser et al. 2023 <a href="https://arxiv.org/abs/2302.03011">&ldquo;Structure and Content-Guided Video Synthesis with Diffusion Models.&rdquo;</a></p>
<p>[13] Bar-Tal et al. 2024 <a href="https://arxiv.org/abs/2401.12945">&ldquo;Lumiere: A Space-Time Diffusion Model for Video Generation.&rdquo;</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://lilianweng.github.io/tags/generative-model/">Generative-Model</a></li>
      <li><a href="https://lilianweng.github.io/tags/video-generation/">Video-Generation</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://lilianweng.github.io/posts/2024-07-07-hallucination/">
    <span class="title">¬´ </span>
    <br>
    <span>Extrinsic Hallucinations in LLMs</span>
  </a>
  <a class="next" href="https://lilianweng.github.io/posts/2024-02-05-human-data-quality/">
    <span class="title"> ¬ª</span>
    <br>
    <span>Thinking about High-Quality Human Data</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on twitter"
        href="https://twitter.com/intent/tweet/?text=Diffusion%20Models%20for%20Video%20Generation&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f&amp;hashtags=generative-model%2cvideo-generation">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f&amp;title=Diffusion%20Models%20for%20Video%20Generation&amp;summary=Diffusion%20Models%20for%20Video%20Generation&amp;source=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f&title=Diffusion%20Models%20for%20Video%20Generation">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on whatsapp"
        href="https://api.whatsapp.com/send?text=Diffusion%20Models%20for%20Video%20Generation%20-%20https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Diffusion Models for Video Generation on telegram"
        href="https://telegram.me/share/url?text=Diffusion%20Models%20for%20Video%20Generation&amp;url=https%3a%2f%2flilianweng.github.io%2fposts%2f2024-04-12-diffusion-video%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://lilianweng.github.io/">Lil&#39;Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
